import type { default as CodeMirror_2 } from 'codemirror';
import type { Editor as Editor_2 } from 'codemirror';
import type { EditorConfiguration } from 'codemirror';
import type { Position } from 'codemirror';

declare interface Alternative {
    alt?: string | null | undefined;
}

declare type AttributeValue = string | [string, ...PrimitivePropertyValue[]]

declare class Buffer extends Uint8Array {
    length: number
    write(string: string, offset?: number, length?: number, encoding?: string): number;
    toString(encoding?: string, start?: number, end?: number): string;
    toJSON(): { type: 'Buffer', data: any[] };
    equals(otherBuffer: Buffer): boolean;
    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;
    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    slice(start?: number, end?: number): Buffer;
    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    readUInt8(offset: number, noAssert?: boolean): number;
    readUInt16LE(offset: number, noAssert?: boolean): number;
    readUInt16BE(offset: number, noAssert?: boolean): number;
    readUInt32LE(offset: number, noAssert?: boolean): number;
    readUInt32BE(offset: number, noAssert?: boolean): number;
    readInt8(offset: number, noAssert?: boolean): number;
    readInt16LE(offset: number, noAssert?: boolean): number;
    readInt16BE(offset: number, noAssert?: boolean): number;
    readInt32LE(offset: number, noAssert?: boolean): number;
    readInt32BE(offset: number, noAssert?: boolean): number;
    readFloatLE(offset: number, noAssert?: boolean): number;
    readFloatBE(offset: number, noAssert?: boolean): number;
    readDoubleLE(offset: number, noAssert?: boolean): number;
    readDoubleBE(offset: number, noAssert?: boolean): number;
    reverse(): this;
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;
    writeUInt8(value: number, offset: number, noAssert?: boolean): number;
    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;
    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;
    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;
    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;
    writeInt8(value: number, offset: number, noAssert?: boolean): number;
    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;
    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;
    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;
    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;
    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;
    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;
    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;
    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;
    fill(value: any, offset?: number, end?: number): this;
    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;
    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;

    /**
     * Allocates a new buffer containing the given {str}.
     *
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     */
    constructor (str: string, encoding?: string);
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     */
    constructor (size: number);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     */
    constructor (array: Uint8Array);
    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}.
     *
     *
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     */
    constructor (arrayBuffer: ArrayBuffer);
    /**
     * Allocates a new buffer containing the given {array} of octets.
     *
     * @param array The octets to store.
     */
    constructor (array: any[]);
    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     *
     * @param buffer The buffer to copy.
     */
    constructor (buffer: Buffer);
    prototype: Buffer;
    /**
     * Allocates a new Buffer using an {array} of octets.
     *
     * @param array
     */
    static from(array: any[]): Buffer;
    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
     * The optional {byteOffset} and {length} arguments specify a memory range
     * within the {arrayBuffer} that will be shared by the Buffer.
     *
     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()
     * @param byteOffset
     * @param length
     */
    static from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;
    /**
     * Copies the passed {buffer} data onto a new Buffer instance.
     *
     * @param buffer
     */
    static from(buffer: Buffer | Uint8Array): Buffer;
    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
     * If not provided, {encoding} defaults to 'utf8'.
     *
     * @param str
     */
    static from(str: string, encoding?: string): Buffer;
    /**
     * Returns true if {obj} is a Buffer
     *
     * @param obj object to test.
     */
    static isBuffer(obj: any): obj is Buffer;
    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     *
     * @param encoding string to test.
     */
    static isEncoding(encoding: string): boolean;
    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     *
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    static byteLength(string: string, encoding?: string): number;
    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     *
     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
     * If the list has exactly one item, then the first item of the list is returned.
     * If the list has more than one item, then a new Buffer is created.
     *
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
     */
    static concat(list: Buffer[], totalLength?: number): Buffer;
    /**
     * The same as buf1.compare(buf2).
     */
    static compare(buf1: Buffer, buf2: Buffer): number;
    /**
     * Allocates a new buffer of {size} octets.
     *
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
     *    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initializing
     */
    static alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;
    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafe(size: number): Buffer;
    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     *
     * @param size count of octets to allocate
     */
    static allocUnsafeSlow(size: number): Buffer;
}

/**
 * Encodings supported by the buffer class.
 * This is a copy of the typing from Node, copied to prevent Node globals from
 * being needed.
 * Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>
 */
declare type BufferEncoding =
| 'ascii'
| 'utf8'
| 'utf-8'
| 'utf16le'
| 'ucs2'
| 'ucs-2'
| 'base64'
| 'base64url'
| 'latin1'
| 'binary'
| 'hex'

export declare interface BytemdAction {
    /**
     * Action title
     */
    title?: string;
    /**
     * Action icon (16x16), usually inline svg
     */
    icon?: string;
    /**
     * Markdown syntax cheatsheet
     *
     * If specified, this record will be added to the Markdown cheatsheet section
     */
    cheatsheet?: string;
    /**
     * Action handler
     */
    handler?: BytemdActionHandler;
}

declare type BytemdActionHandler = {
    type: 'action';
    click: Listener;
    /**
     * Keyboard shortcut
     *
     * If specified, this shortcut will bind to click listener
     * and will be added to the Keyboard shortcut section
     *
     * https://codemirror.net/doc/manual.html#keymaps
     */
    shortcut?: string;
    /**
     * mouseenter event listener, only takes effect in dropdown items
     */
    mouseenter?: Listener;
    /**
     * mouseleave event listener, only takes effect in dropdown items
     */
    mouseleave?: Listener;
} | {
    type: 'dropdown';
    actions: BytemdAction[];
};

export declare interface BytemdEditorContext extends EditorUtils {
    codemirror: typeof CodeMirror_2;
    /**
     * CodeMirror editor instance
     */
    editor: Editor_2;
    /**
     * The root element
     */
    root: HTMLElement;
}

export declare interface BytemdLocale {
    write: string;
    preview: string;
    writeOnly: string;
    exitWriteOnly: string;
    previewOnly: string;
    exitPreviewOnly: string;
    help: string;
    closeHelp: string;
    toc: string;
    closeToc: string;
    fullscreen: string;
    exitFullscreen: string;
    source: string;
    cheatsheet: string;
    shortcuts: string;
    words: string;
    lines: string;
    sync: string;
    top: string;
    limited: string;
    h1: string;
    h2: string;
    h3: string;
    h4: string;
    h5: string;
    h6: string;
    headingText: string;
    bold: string;
    boldText: string;
    italic: string;
    italicText: string;
    quote: string;
    quotedText: string;
    link: string;
    linkText: string;
    image: string;
    imageAlt: string;
    imageTitle: string;
    code: string;
    codeText: string;
    codeBlock: string;
    codeLang: string;
    ul: string;
    ulItem: string;
    ol: string;
    olItem: string;
    hr: string;
}

export declare interface BytemdPlugin {
    /**
     * Customize Markdown parse by remark plugins:
     *
     * https://github.com/remarkjs/remark/blob/main/doc/plugins.md
     */
    remark?: (p: Processor) => Processor;
    /**
     * Customize HTML parse by rehype plugins:
     *
     * https://github.com/rehypejs/rehype/blob/main/doc/plugins.md
     */
    rehype?: (p: Processor) => Processor;
    /**
     * Register actions in toolbar, cheatsheet and shortcuts
     */
    actions?: BytemdAction[];
    /**
     * Side effect for the editor, triggers when plugin changes
     */
    editorEffect?(ctx: BytemdEditorContext): void | (() => void);
    /**
     * Side effect for the viewer, triggers when viewer props changes
     */
    viewerEffect?(ctx: BytemdViewerContext): void | (() => void);
}

export declare interface BytemdViewerContext {
    /**
     * The root element of the viewer
     */
    markdownBody: HTMLElement;
    /**
     * Virtual file format used in [unified](https://unifiedjs.com/)
     *
     * Get the HTML output by calling `vfile.toString()`
     */
    file: VFile;
}

/**
 * Represents an HTML Comment.
 */
declare interface Comment_2 extends Literal {
    /**
     * Represents this variant of a Literal.
     */
    type: 'comment';
}

/**
 * Function handling the compilation of syntax tree to a text.
 * Used in the stringify phase in the process and called with a `Node` and
 * `VFile` representation of the document to stringify.
 *
 * `Compiler` can be a normal function, in which case it must return a
 * `string`: the text representation of the given syntax tree.
 *
 * `Compiler` can also be a constructor function (a function with keys in its
 * `prototype`), in which case it’s called with `new`.
 * Instances must have a `compile` method that is called without arguments
 * and must return a `string`.
 *
 * @typeParam Tree
 *   The node that the compiler receives.
 * @typeParam Result
 *   The thing that the compiler yields.
 */
declare type Compiler<Tree extends Node_2 = Node_2, Result = unknown> =
| CompilerClass<Tree, Result>
| CompilerFunction<Tree, Result>

/**
 * A class to compile trees.
 *
 * @typeParam Tree
 *   The node that the compiler receives.
 * @typeParam Result
 *   The thing that the compiler yields.
 */
declare class CompilerClass<Tree extends Node_2 = Node_2, Result = unknown> {
    prototype: {
        /**
         * Compile a tree.
         *
         * @returns
         *   New content: compiled text (`string` or `Buffer`, for `file.value`) or
         *   something else (for `file.result`).
         */
        compile(): Result
    }

    /**
     * Constructor.
     *
     * @param tree
     *   Tree to compile.
     * @param file
     *   File associated with `tree`.
     * @returns
     *   Instance.
     */
    constructor(tree: Tree, file: VFile)
}

/**
 * Normal function to compile a tree.
 *
 * @typeParam Tree
 *   The node that the compiler receives.
 * @typeParam Result
 *   The thing that the compiler yields.
 * @param tree
 *   Tree to compile.
 * @param file
 *   File associated with `tree`.
 * @returns
 *   New content: compiled text (`string` or `Buffer`, for `file.value`) or
 *   something else (for `file.result`).
 */
declare type CompilerFunction<Tree extends Node_2 = Node_2, Result = unknown> = (
tree: Tree,
file: VFile
) => Result

declare type Content = RootContent | ElementContent;

declare function createEditorUtils(codemirror: typeof CodeMirror_2, editor: Editor_2): {
    /**
     * Wrap text with decorators, for example:
     *
     * `text -> *text*`
     */
    wrapText(before: string, after?: string): void;
    /**
     * replace multiple lines
     *
     * `line -> # line`
     */
    replaceLines(replace: Parameters<Array<string>['map']>[0]): void;
    /**
     * Append a block based on the cursor position
     */
    appendBlock(content: string): Position;
    /**
     * Triggers a virtual file input and let user select files
     *
     * https://www.npmjs.com/package/select-files
     */
    selectFiles: (options?: Options | undefined) => Promise<FileList | null>;
};

/**
 * Information associated by the ecosystem with the node.
 * Space is guaranteed to never be specified by unist or specifications
 * implementing unist.
 */
declare interface Data {
    [key: string]: unknown;
}

/**
 * Represents an HTML DocumentType.
 */
declare interface DocType extends Node_2 {
    /**
     * Represents this variant of a Node.
     */
    type: 'doctype';

    name: string;
}

export declare interface EditorProps extends ViewerProps {
    /**
     * Editor display mode
     *
     * - `split`: edit on the left and preview on the right
     * - `tab`: click tabs to switch between edit and preview
     * - `auto`: auto determined by the width of editor container
     *
     * @defaultValue `auto`
     */
    mode?: 'split' | 'tab' | 'auto';
    /**
     * Debounce time (ms) for preview
     *
     * @defaultValue 300
     */
    previewDebounce?: number;
    /**
     * Editor placeholder
     */
    placeholder?: string;
    /**
     * CodeMirror editor config
     *
     * https://codemirror.net/doc/manual.html#config
     */
    editorConfig?: Omit<EditorConfiguration, 'value' | 'placeholder'>;
    /**
     * i18n locale
     *
     * @defaultValue en
     */
    locale?: Partial<BytemdLocale>;
    /**
     * Handle images upload
     */
    uploadImages?: (files: File[]) => Promise<Pick<Image_2, 'url' | 'alt' | 'title'>[]>;
    /**
     * Override the default preview area render
     *
     * If specified, the built-in viewer would not take effect.
     */
    overridePreview?(el: HTMLElement, props: ViewerProps): void;
    /**
     * Maximum length (number of characters) of value
     */
    maxLength?: number;
}

declare type EditorUtils = ReturnType<typeof createEditorUtils>;

/**
 * Element represents an HTML Element.
 */
declare interface Element_2 extends Parent {
    /**
     * Represents this variant of a Node.
     */
    type: 'element';

    /**
     * Represents the element’s local name.
     */
    tagName: string;

    /**
     * Represents information associated with the element.
     */
    properties?: Properties_2 | undefined;

    /**
     * If the tagName field is 'template', a content field can be present.
     */
    content?: Root | undefined;

    /**
     * List representing the children of a node.
     */
    children: ElementContent[];
}

declare type ElementContent = ElementContentMap[keyof ElementContentMap];

/**
 * This map registers all node types that may be used as content in an element.
 *
 * These types are accepted inside `element` nodes.
 *
 * This interface can be augmented to register custom node types.
 *
 * @example
 * declare module 'hast' {
 *   interface RootContentMap {
 *     custom: Custom;
 *   }
 * }
 */
declare interface ElementContentMap {
    comment: Comment_2;
    element: Element_2;
    text: Text_2;
}

/**
 * INTERNAL, DO NOT USE. Code may change at any time.
 */
declare interface Fragment {
    key: string | null;
    first: null;
    c: () => void;
    l: (nodes: any) => void;
    h: () => void;
    m: (target: HTMLElement, anchor: any) => void;
    p: (ctx: any, dirty: any) => void;
    r: () => void;
    f: () => void;
    a: () => void;
    i: (local: any) => void;
    o: (local: any) => void;
    d: (detaching: 0 | 1) => void;
}

/**
 * A frozen processor is just like a regular processor, except no additional
 * plugins can be added.
 * A frozen processor can be created by calling `.freeze()` on a processor.
 * An unfrozen processor can be created by calling a processor.
 */
declare interface FrozenProcessor<
ParseTree extends Node_2 | void = void,
CurrentTree extends Node_2 | void = void,
CompileTree extends Node_2 | void = void,
CompileResult = void
> {
    /**
     * Clone current processor
     *
     * @returns
     *   New unfrozen processor that is configured to function the same as its
     *   ancestor.
     *   But when the descendant processor is configured it does not affect the
     *   ancestral processor.
     */
    (): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

    /**
     * Internal list of configured plugins.
     *
     * @private
     */
    attachers: Array<[Plugin_2, ...unknown[]]>

    Parser?: Parser<Specific<Node_2, ParseTree>> | undefined
    Compiler?:
    | Compiler<Specific<Node_2, CompileTree>, Specific<unknown, CompileResult>>
    | undefined

    /**
     * Parse a file.
     *
     * @param file
     *   File to parse.
     *   `VFile` or anything that can be given to `new VFile()`, optional.
     * @returns
     *   Resulting tree.
     */
    parse(file?: VFileCompatible | undefined): Specific<Node_2, ParseTree>

    /**
     * Compile a file.
     *
     * @param node
     *   Node to compile.
     * @param file
     *   `VFile` or anything that can be given to `new VFile()`, optional.
     * @returns
     *   New content: compiled text (`string` or `Buffer`) or something else.
     *   This depends on which plugins you use: typically text, but could for
     *   example be a React node.
     */
    stringify(
    node: Specific<Node_2, CompileTree>,
    file?: VFileCompatible | undefined
    ): CompileTree extends Node_2 ? CompileResult : unknown

    /**
     * Run transforms on the given tree.
     *
     * @param node
     *   Tree to transform.
     * @param callback
     *   Callback called with an error or the resulting node.
     * @returns
     *   Nothing.
     */
    run(
    node: Specific<Node_2, ParseTree>,
    callback: RunCallback<Specific<Node_2, CompileTree>>
    ): void

    /**
     * Run transforms on the given node.
     *
     * @param node
     *   Tree to transform.
     * @param file
     *   File associated with `node`.
     *   `VFile` or anything that can be given to `new VFile()`.
     * @param callback
     *   Callback called with an error or the resulting node.
     * @returns
     *   Nothing.
     */
    run(
    node: Specific<Node_2, ParseTree>,
    file: VFileCompatible | undefined,
    callback: RunCallback<Specific<Node_2, CompileTree>>
    ): void

    /**
     * Run transforms on the given node.
     *
     * @param node
     *   Tree to transform.
     * @param file
     *   File associated with `node`.
     *   `VFile` or anything that can be given to `new VFile()`.
     * @returns
     *   Promise that resolves to the resulting tree.
     */
    run(
    node: Specific<Node_2, ParseTree>,
    file?: VFileCompatible | undefined
    ): Promise<Specific<Node_2, CompileTree>>

    /**
     * Run transforms on the given node, synchronously.
     * Throws when asynchronous transforms are configured.
     *
     * @param node
     *   Tree to transform.
     * @param file
     *   File associated with `node`.
     *   `VFile` or anything that can be given to `new VFile()`, optional.
     * @returns
     *   Resulting tree.
     */
    runSync(
    node: Specific<Node_2, ParseTree>,
    file?: VFileCompatible | undefined
    ): Specific<Node_2, CompileTree>

    /**
     * Process a file.
     *
     * This performs all phases of the processor:
     *
     * 1.  Parse a file into a unist node using the configured `Parser`
     * 2.  Run transforms on that node
     * 3.  Compile the resulting node using the `Compiler`
     *
     * The result from the compiler is stored on the file.
     * What the result is depends on which plugins you use.
     * The result is typically text (`string` or `Buffer`), which can be retrieved
     * with `file.toString()` (or `String(file)`).
     * In some cases, such as when using `rehypeReact` to create a React node,
     * the result is stored on `file.result`.
     *
     * @param file
     *   `VFile` or anything that can be given to `new VFile()`.
     * @param callback
     *   Callback called with an error or the resulting file.
     * @returns
     *   Nothing.
     */
    process(
    file: VFileCompatible | undefined,
    callback: ProcessCallback<VFileWithOutput<CompileResult>>
    ): void

    /**
     * Process a file.
     *
     * This performs all phases of the processor:
     *
     * 1.  Parse a file into a unist node using the configured `Parser`
     * 2.  Run transforms on that node
     * 3.  Compile the resulting node using the `Compiler`
     *
     * The result from the compiler is stored on the file.
     * What the result is depends on which plugins you use.
     * The result is typically text (`string` or `Buffer`), which can be retrieved
     * with `file.toString()` (or `String(file)`).
     * In some cases, such as when using `rehypeReact` to create a React node,
     * the result is stored on `file.result`.
     *
     * @param file
     *   `VFile` or anything that can be given to `new VFile()`.
     * @returns
     *   Promise that resolves to the resulting `VFile`.
     */
    process(file: VFileCompatible): Promise<VFileWithOutput<CompileResult>>

    /**
     * Process a file, synchronously.
     * Throws when asynchronous transforms are configured.
     *
     * This performs all phases of the processor:
     *
     * 1.  Parse a file into a unist node using the configured `Parser`
     * 2.  Run transforms on that node
     * 3.  Compile the resulting node using the `Compiler`
     *
     * The result from the compiler is stored on the file.
     * What the result is depends on which plugins you use.
     * The result is typically text (`string` or `Buffer`), which can be retrieved
     * with `file.toString()` (or `String(file)`).
     * In some cases, such as when using `rehypeReact` to create a React node,
     * the result is stored on `file.result`.
     *
     * @param file
     *   `VFile` or anything that can be given to `new VFile()`, optional.
     * @returns
     *   Resulting file.
     */
    processSync(
    file?: VFileCompatible | undefined
    ): VFileWithOutput<CompileResult>

    /**
     * Get an in-memory key-value store accessible to all phases of the process.
     *
     * @returns
     *   Key-value store.
     */
    data(): Record<string, unknown>

    /**
     * Set an in-memory key-value store accessible to all phases of the process.
     *
     * @param data
     *   Key-value store.
     * @returns
     *   Current processor.
     */
    data(
    data: Record<string, unknown>
    ): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

    /**
     * Get an in-memory value by key.
     *
     * @param key
     *   Key to get.
     * @returns
     *   The value at `key`.
     */
    data(key: string): unknown

    /**
     * Set an in-memory value by key.
     *
     * @param key
     *   Key to set.
     * @param value
     *   Value to set.
     * @returns
     *   Current processor.
     */
    data(
    key: string,
    value: unknown
    ): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

    /**
     * Freeze a processor.
     * Frozen processors are meant to be extended and not to be configured or
     * processed directly.
     *
     * Once a processor is frozen it cannot be unfrozen.
     * New processors working just like it can be created by calling the
     * processor.
     *
     * It’s possible to freeze processors explicitly, by calling `.freeze()`, but
     * `.parse()`, `.run()`, `.stringify()`, and `.process()` call `.freeze()` to
     * freeze a processor too.
     *
     * @returns
     *   Frozen processor.
     */
    freeze(): FrozenProcessor<ParseTree, CurrentTree, CompileTree, CompileResult>
}

/**
 * Get unified processor with ByteMD plugins
 */
export declare function getProcessor({ sanitize, plugins, }: Omit<ViewerProps, 'value'>): Processor<Root, Root, Root, string>;

declare interface IComponentOptions<Props extends Record<string, any> = Record<string, any>> {
    target: Element | ShadowRoot;
    anchor?: Element;
    props?: Props;
    context?: Map<any, any>;
    hydrate?: boolean;
    intro?: boolean;
    $$inline?: boolean;
}

declare interface Image_2 extends Node_2, Resource, Alternative {
    type: 'image';
}

declare type Listener = (context: BytemdEditorContext) => void;

/**
 * Nodes in hast containing a value.
 */
declare interface Literal extends Literal_2 {
    value: string;
}

/**
 * Nodes containing a value.
 *
 * @typeParam Value Specific value type of {@link Literal.value} such as `string` for `Text` node
 */
declare interface Literal_2<Value = unknown, TData extends object = Data> extends Node_2<TData> {
    value: Value;
}

/**
 * Raw source map, see:
 * <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.
 */
declare type Map_2 = {
    version: number
    sources: Array<string>
    names: Array<string>
    sourceRoot?: string | undefined
    sourcesContent?: Array<string> | undefined
    mappings: string
    file: string
}

/**
 * This is the same as `Buffer` if node types are included, `never` otherwise.
 */
declare type MaybeBuffer = any extends Buffer ? never : Buffer

/**
 * Syntactic units in unist syntax trees are called nodes.
 *
 * @typeParam TData Information from the ecosystem. Useful for more specific {@link Node.data}.
 */
declare interface Node_2<TData extends object = Data> {
    /**
     * The variant of a node.
     */
    type: string;

    /**
     * Information from the ecosystem.
     */
    data?: TData | undefined;

    /**
     * Location of a node in a source document.
     * Must not be present if a node is generated.
     */
    position?: Position_2 | undefined;
}

/**
 * Util for extracting type of {@link Node.data}
 *
 * @typeParam TNode Specific node type such as {@link Node} with {@link Data}, {@link Literal}, etc.
 *
 * @example `NodeData<Node<{ key: string }>>` -> `{ key: string }`
 */
declare type NodeData<TNode extends Node_2<object>> = TNode extends Node_2<infer TData> ? TData : never;

declare type NodeLike = object & {
    type: string
    position?: Position_3 | undefined
}

declare type NodeLike_2 = Record<string, unknown> & {
    type: string
    position?: Position_4 | undefined
}

/**
 * Type of options for file input element (`<input type="file" />`) virtually
 * created to select files.
 */
declare type Options = {
    /**
     * Defines accepted file types. It's a comma-separated list of file
     * extensions, mime-types or unique file type specifiers.
     *
     * https://developer.mozilla.org/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers
     *
     * @example ```js
     * "image/*,video/*,.pdf,.doc,.docx,.xls"
     * ```
     */
    accept?: string;
    /**
     * Combined with `accept` property it specifies which camera to use for
     * capture of image or video. It was previously a Boolean value.
     */
    capture?: string | boolean;
    /**
     * Allow multiple files selection.
     */
    multiple?: boolean;
};

/**
 * Node in hast containing other nodes.
 */
declare interface Parent extends Parent_2 {
    /**
     * List representing the children of a node.
     */
    children: Content[];
}

/**
 * Nodes containing other nodes.
 *
 * @typeParam ChildNode Node item of {@link Parent.children}
 */
declare interface Parent_2<ChildNode extends Node_2<object> = Node_2, TData extends object = NodeData<ChildNode>>
extends Node_2<TData> {
    /**
     * List representing the children of a node.
     */
    children: ChildNode[];
}

/**
 * Function handling the parsing of text to a syntax tree.
 * Used in the parse phase in the process and called with a `string` and
 * `VFile` representation of the document to parse.
 *
 * `Parser` can be a normal function, in which case it must return a `Node`:
 * the syntax tree representation of the given file.
 *
 * `Parser` can also be a constructor function (a function with keys in its
 * `prototype`), in which case it’s called with `new`.
 * Instances must have a parse method that is called without arguments and
 * must return a `Node`.
 *
 * @typeParam Tree
 *   The node that the parser yields (and `run` receives).
 */
declare type Parser<Tree extends Node_2 = Node_2> =
| ParserClass<Tree>
| ParserFunction<Tree>

/**
 * A class to parse files.
 *
 * @typeParam Tree
 *   The node that the parser yields.
 */
declare class ParserClass<Tree extends Node_2 = Node_2> {
    prototype: {
        /**
         * Parse a file.
         *
         * @returns
         *   Parsed tree.
         */
        parse(): Tree
    }

    /**
     * Constructor.
     *
     * @param document
     *   Document to parse.
     * @param file
     *   File associated with `document`.
     * @returns
     *   Instance.
     */
    constructor(document: string, file: VFile)
}

/**
 * Normal function to parse a file.
 *
 * @typeParam Tree
 *   The node that the parser yields.
 * @param document
 *   Document to parse.
 * @param file
 *   File associated with `document`.
 * @returns
 *   Node representing the given file.
 */
declare type ParserFunction<Tree extends Node_2 = Node_2> = (
document: string,
file: VFile
) => Tree

/**
 * A union of the different ways to add plugins and settings.
 *
 * @typeParam PluginParameters
 *   Plugin settings.
 */
declare type Pluggable<PluginParameters extends any[] = any[]> =
| PluginTuple<PluginParameters, any, any>
| Plugin_2<PluginParameters, any, any>
| Preset

/**
 * A list of plugins and presets.
 */
declare type PluggableList = Pluggable[]

/**
 * A plugin is a function.
 * It configures the processor and in turn can receive options.
 * Plugins can configure processors by interacting with parsers and compilers
 * (at `this.Parser` or `this.Compiler`) or by specifying how the syntax tree
 * is handled (by returning a `Transformer`).
 *
 * @typeParam PluginParameters
 *   Plugin settings.
 * @typeParam Input
 *   Value that is accepted by the plugin.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer expects.
 *   *   If the plugin sets a parser, then this should be `string`.
 *   *   If the plugin sets a compiler, then this should be the node type that
 *       the compiler expects.
 * @typeParam Output
 *   Value that the plugin yields.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer yields, and defaults to `Input`.
 *   *   If the plugin sets a parser, then this should be the node type that
 *       the parser yields.
 *   *   If the plugin sets a compiler, then this should be the result that
 *       the compiler yields (`string`, `Buffer`, or something else).
 * @this
 *   The current processor.
 *   Plugins can configure the processor by interacting with `this.Parser` or
 *   `this.Compiler`, or by accessing the data associated with the whole process
 *   (`this.data`).
 * @param settings
 *   Configuration for plugin.
 *   Plugins typically receive one options object, but could receive other and
 *   more values.
 *   Users can also pass a boolean instead of settings: `true` (to turn
 *   a plugin on) or `false` (to turn a plugin off).
 *   When a plugin is turned off, it won’t be called.
 *
 *   When creating your own plugins, please accept only a single object!
 *   It allows plugins to be reconfigured and it helps users to know that every
 *   plugin accepts one options object.
 * @returns
 *   Plugins can return a `Transformer` to specify how the syntax tree is
 *   handled.
 */
declare type Plugin_2<
PluginParameters extends any[] = any[],
Input = Node_2,
Output = Input
> = (
this: Input extends Node_2
? Output extends Node_2
? // This is a transform, so define `Input` as the current tree.
Processor<void, Input>
: // Compiler.
Processor<void, Input, Input, Output>
: Output extends Node_2
? // Parser.
Processor<Output, Output>
: // No clue.
Processor,
...settings: PluginParameters
) => // If both `Input` and `Output` are `Node`, expect an optional `Transformer`.
Input extends Node_2
? Output extends Node_2
? Transformer_2<Input, Output> | void
: void
: void

/**
 * A tuple of a plugin and its setting(s).
 * The first item is a plugin (function) to use and other items are options.
 * Plugins are deduped based on identity: passing a function in twice will
 * cause it to run only once.
 *
 * @typeParam PluginParameters
 *   Plugin settings.
 * @typeParam Input
 *   Value that is accepted by the plugin.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer expects.
 *   *   If the plugin sets a parser, then this should be `string`.
 *   *   If the plugin sets a compiler, then this should be the node type that
 *       the compiler expects.
 * @typeParam Output
 *   Value that the plugin yields.
 *
 *   *   If the plugin returns a transformer, then this should be the node
 *       type that the transformer yields, and defaults to `Input`.
 *   *   If the plugin sets a parser, then this should be the node type that
 *       the parser yields.
 *   *   If the plugin sets a compiler, then this should be the result that
 *       the compiler yields (`string`, `Buffer`, or something else).
 */
declare type PluginTuple<
PluginParameters extends any[] = any[],
Input = Node_2,
Output = Input
> = [Plugin_2<PluginParameters, Input, Output>, ...PluginParameters]

/**
 * One place in a source file.
 */
declare interface Point {
    /**
     * Line in a source file (1-indexed integer).
     */
    line: number;

    /**
     * Column in a source file (1-indexed integer).
     */
    column: number;
    /**
     * Character in a source file (0-indexed integer).
     */
    offset?: number | undefined;
}

/**
 * Location of a node in a source file.
 */
declare interface Position_2 {
    /**
     * Place of the first character of the parsed source region.
     */
    start: Point;

    /**
     * Place of the first character after the parsed source region.
     */
    end: Point;

    /**
     * Start column at each index (plus start line) in the source region,
     * for elements that span multiple lines.
     */
    indent?: number[] | undefined;
}

declare type Position_3 = Position_2

declare type Position_4 = Position_2

/**
 * Presets provide a sharable way to configure processors with multiple plugins
 * and/or settings.
 */
declare interface Preset {
    plugins?: PluggableList
    settings?: Record<string, unknown>
}

/**
 * Possible primitive HTML attribute values
 */
declare type PrimitivePropertyValue = string | number | boolean

/**
 * Callback called when a done processing.
 *
 * @typeParam File
 *   The file that the callback receives.
 * @param error
 *   Error passed when unsuccessful.
 * @param file
 *   File passed when successful.
 * @returns
 *   Nothing.
 */
declare type ProcessCallback<File extends VFile = VFile> = (
error?: Error | null | undefined,
file?: File | undefined
) => void

/**
 * Processor allows plugins to be chained together to transform content.
 * The chain of plugins defines how content flows through it.
 *
 * @typeParam ParseTree
 *   The node that the parser yields (and `run` receives).
 * @typeParam CurrentTree
 *   The node that the last attached plugin yields.
 * @typeParam CompileTree
 *   The node that the compiler receives (and `run` yields).
 * @typeParam CompileResult
 *   The thing that the compiler yields.
 */
declare interface Processor<
ParseTree extends Node_2 | void = void,
CurrentTree extends Node_2 | void = void,
CompileTree extends Node_2 | void = void,
CompileResult = void
> extends FrozenProcessor<ParseTree, CurrentTree, CompileTree, CompileResult> {
    /**
     * Configure the processor to use a plugin.
     *
     * @typeParam PluginParameters
     *   Plugin settings.
     * @typeParam Input
     *   Value that is accepted by the plugin.
     *
     *   *   If the plugin returns a transformer, then this should be the node
     *       type that the transformer expects.
     *   *   If the plugin sets a parser, then this should be `string`.
     *   *   If the plugin sets a compiler, then this should be the node type that
     *       the compiler expects.
     * @typeParam Output
     *   Value that the plugin yields.
     *
     *   *   If the plugin returns a transformer, then this should be the node
     *       type that the transformer yields, and defaults to `Input`.
     *   *   If the plugin sets a parser, then this should be the node type that
     *       the parser yields.
     *   *   If the plugin sets a compiler, then this should be the result that
     *       the compiler yields (`string`, `Buffer`, or something else).
     * @param plugin
     *   Plugin (function) to use.
     *   Plugins are deduped based on identity: passing a function in twice will
     *   cause it to run only once.
     * @param settings
     *   Configuration for plugin, optional.
     *   Plugins typically receive one options object, but could receive other and
     *   more values.
     *   It’s also possible to pass a boolean instead of settings: `true` (to turn
     *   a plugin on) or `false` (to turn a plugin off).
     * @returns
     *   Current processor.
     */
    use<
    PluginParameters extends any[] = any[],
    Input = Specific<Node_2, CurrentTree>,
    Output = Input
    >(
    plugin: Plugin_2<PluginParameters, Input, Output>,
    ...settings: PluginParameters | [boolean]
    ): UsePlugin<
    ParseTree,
    CurrentTree,
    CompileTree,
    CompileResult,
    Input,
    Output
    >

    /**
     * Configure the processor with a tuple of a plugin and setting(s).
     *
     * @typeParam PluginParameters
     *   Plugin settings.
     * @typeParam Input
     *   Value that is accepted by the plugin.
     *
     *   *   If the plugin returns a transformer, then this should be the node
     *       type that the transformer expects.
     *   *   If the plugin sets a parser, then this should be `string`.
     *   *   If the plugin sets a compiler, then this should be the node type that
     *       the compiler expects.
     * @typeParam Output
     *   Value that the plugin yields.
     *
     *   *   If the plugin returns a transformer, then this should be the node
     *       type that the transformer yields, and defaults to `Input`.
     *   *   If the plugin sets a parser, then this should be the node type that
     *       the parser yields.
     *   *   If the plugin sets a compiler, then this should be the result that
     *       the compiler yields (`string`, `Buffer`, or something else).
     * @param tuple
     *   A tuple where the first item is a plugin (function) to use and other
     *   items are options.
     *   Plugins are deduped based on identity: passing a function in twice will
     *   cause it to run only once.
     *   It’s also possible to pass a boolean instead of settings: `true` (to turn
     *   a plugin on) or `false` (to turn a plugin off).
     * @returns
     *   Current processor.
     */
    use<
    PluginParameters extends any[] = any[],
    Input = Specific<Node_2, CurrentTree>,
    Output = Input
    >(
    tuple:
    | PluginTuple<PluginParameters, Input, Output>
    | [Plugin_2<PluginParameters, Input, Output>, boolean]
    ): UsePlugin<
    ParseTree,
    CurrentTree,
    CompileTree,
    CompileResult,
    Input,
    Output
    >

    /**
     * Configure the processor with a preset or list of plugins and presets.
     *
     * @param presetOrList
     *   Either a list of plugins, presets, and tuples, or a single preset: an
     *   object with a `plugins` (list) and/or `settings`
     *   (`Record<string, unknown>`).
     * @returns
     *   Current processor.
     */
    use(
    presetOrList: Preset | PluggableList
    ): Processor<ParseTree, CurrentTree, CompileTree, CompileResult>
}

declare type Properties = Properties_2

/**
 * Represents information associated with an element.
 */
declare interface Properties_2 {
    [PropertyName: string]: boolean | number | string | null | undefined | Array<string | number>;
}

/**
 * Possible property values
 */
declare type PropertyValue = Properties[string]

declare type Props = Record<string, any>;

declare interface Resource {
    url: string;
    title?: string | null | undefined;
}

/**
 * Root represents a document.
 * Can be used as the rood of a tree, or as a value of the
 * content field on a 'template' Element, never as a child.
 */
declare interface Root extends Parent {
    /**
     * Represents this variant of a Node.
     */
    type: 'root';

    /**
     * List representing the children of a node.
     */
    children: RootContent[];
}

declare type RootContent = RootContentMap[keyof RootContentMap];

/**
 * This map registers all node types that may be used as top-level content in the document.
 *
 * These types are accepted inside `root` nodes.
 *
 * This interface can be augmented to register custom node types.
 *
 * @example
 * declare module 'hast' {
 *   interface RootContentMap {
 *     // Allow using raw nodes defined by `rehype-raw`.
 *     raw: Raw;
 *   }
 * }
 */
declare interface RootContentMap {
    comment: Comment_2;
    doctype: DocType;
    element: Element_2;
    text: Text_2;
}

/**
 * Callback called when a done running.
 *
 * @typeParam Tree
 *   The tree that the callback receives.
 * @param error
 *   Error passed when unsuccessful.
 * @param node
 *   Tree to transform.
 * @param file
 *   File passed when successful.
 * @returns
 *   Nothing.
 */
declare type RunCallback<Tree extends Node_2 = Node_2> = (
error?: Error | null | undefined,
node?: Tree | undefined,
file?: VFile | undefined
) => void

declare type Schema = Schema_2

/**
 * Sanitization configuration
 */
declare type Schema_2 = {
    /**
     * Map of tag names to allowed property names. The special '*' key defines property names allowed on all elements
     */
    attributes?: {
        [x: string]: Array<AttributeValue>
    }
    /**
     * Map of tag names to required property names and their default property value
     */
    required?: {
        [x: string]: {
            [x: string]: PropertyValue
        }
    }
    /**
     * List of allowed tag names
     */
    tagNames?: Array<string>
    /**
     * Map of protocols to allow in property values
     */
    protocols?: {
        [x: string]: Array<string>
    }
    /**
     * Map of tag names to their required ancestor elements
     */
    ancestors?: {
        [x: string]: Array<string>
    }
    /**
     * List of allowed property names which can clobber
     */
    clobber?: Array<string>
    /**
     * Prefix to use before potentially clobbering property names
     */
    clobberPrefix?: string
    /**
     * Names of elements to strip from the tree
     */
    strip?: Array<string>
    /**
     * Whether to allow comments
     */
    allowComments?: boolean
    /**
     * Whether to allow doctypes
     */
    allowDoctypes?: boolean
}

declare type Specific<Left = void, Right = void> = Right extends void ? Left : Right

/**
 * Base class for Svelte components. Used when dev=false.
 */
declare class SvelteComponent {
    $$: T$$;
    $$set?: ($$props: any) => void;
    $destroy(): void;
    $on(type: any, callback: any): () => void;
    $set($$props: any): void;
}

declare interface SvelteComponentDev {
    $set(props?: Props): void;
    $on(event: string, callback: (event: any) => void): () => void;
    $destroy(): void;
    [accessor: string]: any;
}

/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
declare class SvelteComponentDev extends SvelteComponent {
    /**
     * @private
     * For type checking capabilities only.
     * Does not exist at runtime.
     * ### DO NOT USE!
     */
    $$prop_def: Props;
    /**
     * @private
     * For type checking capabilities only.
     * Does not exist at runtime.
     * ### DO NOT USE!
     */
    $$events_def: any;
    /**
     * @private
     * For type checking capabilities only.
     * Does not exist at runtime.
     * ### DO NOT USE!
     */
    $$slot_def: any;
    constructor(options: IComponentOptions);
    $capture_state(): void;
    $inject_state(): void;
}
export { SvelteComponentDev as Editor }
export { SvelteComponentDev as Viewer }

declare interface T$$ {
    dirty: number[];
    ctx: null | any;
    bound: any;
    update: () => void;
    callbacks: any;
    after_update: any[];
    props: Record<string, 0 | string>;
    fragment: null | false | Fragment;
    not_equal: any;
    before_update: any[];
    context: Map<any, any>;
    on_mount: any[];
    on_destroy: any[];
    skip_bound: boolean;
    on_disconnect: any[];
    root: Element | ShadowRoot;
}

/**
 * Represents an HTML Text.
 */
declare interface Text_2 extends Literal {
    /**
     * Represents this variant of a Literal.
     */
    type: 'text';
}

/**
 * Callback you must call when a transformer is done.
 *
 * @typeParam Tree
 *   Node that the plugin yields.
 * @param error
 *   Pass an error to stop the process.
 * @param node
 *   Pass a tree to continue transformations (and `stringify`) on the new tree.
 * @param file
 *   Pass a file to continue transformations (and `stringify`) on the new file.
 * @returns
 *   Nothing.
 */
declare type TransformCallback<Tree extends Node_2 = Node_2> = (
error?: Error | null | undefined,
node?: Tree | undefined,
file?: VFile | undefined
) => void

/**
 * Transformers modify the syntax tree or metadata of a file.
 * A transformer is a function that is called each time a file is passed
 * through the transform phase.
 * If an error occurs (either because it’s thrown, returned, rejected, or passed
 * to `next`), the process stops.
 *
 * @typeParam Input
 *   Node type that the transformer expects.
 * @typeParam Output
 *   Node type that the transformer yields.
 * @param node
 *   Tree to be transformed.
 * @param file
 *   File associated with node.
 * @param next
 *   Callback that you must call when done.
 *   Note: this is given if you accept three parameters in your transformer.
 *   If you accept up to two parameters, it’s not given, and you can return
 *   a promise.
 * @returns
 *   Any of the following:
 *
 *   * `void` — If nothing is returned, the next transformer keeps using same
 *     tree.
 *   * `Error` — Can be returned to stop the process.
 *   * `Node` — Can be returned and results in further transformations and
 *     `stringify`s to be performed on the new tree.
 *   * `Promise` — If a promise is returned, the function is asynchronous, and
 *      must be resolved (optionally with a `Node`) or rejected (optionally with
 *      an `Error`).
 *
 *   If you accept a `next` callback, nothing should be returned.
 */
declare type Transformer_2<
Input extends Node_2 = Node_2,
Output extends Node_2 = Input
> = (
node: Input,
file: VFile,
next: TransformCallback<Output>
) => Promise<Output | undefined | void> | Output | Error | undefined | void

declare type URL_2 = {
    hash: string
    host: string
    hostname: string
    href: string
    origin: string
    password: string
    pathname: string
    port: string
    protocol: string
    search: string
    searchParams: any
    username: string
    toString: () => string
    toJSON: () => string
}

declare type URL_3 = URL_2

declare type UsePlugin<
ParseTree extends Node_2 | void = void,
CurrentTree extends Node_2 | void = void,
CompileTree extends Node_2 | void = void,
CompileResult = void,
Input = void,
Output = void
> = Output extends Node_2
? Input extends string
? // If `Input` is `string` and `Output` is `Node`, then this plugin
// defines a parser, so set `ParseTree`.
Processor<
Output,
Specific<Output, CurrentTree>,
Specific<Output, CompileTree>,
CompileResult
>
: Input extends Node_2
? // If `Input` is `Node` and `Output` is `Node`, then this plugin defines a
// transformer, its output defines the input of the next, so set
// `CurrentTree`.
Processor<
Specific<Input, ParseTree>,
Output,
Specific<CompileTree, Output>,
CompileResult
>
: // Else, `Input` is something else and `Output` is `Node`:
never
: Input extends Node_2
? // If `Input` is `Node` and `Output` is not a `Node`, then this plugin
// defines a compiler, so set `CompileTree` and `CompileResult`
Processor<
Specific<Input, ParseTree>,
Specific<Input, CurrentTree>,
Input,
Output
>
: // Else, `Input` is not a `Node` and `Output` is not a `Node`.
// Maybe it’s untyped, or the plugin throws an error (`never`), so lets
// just keep it as it was.
Processor<ParseTree, CurrentTree, CompileTree, CompileResult>

declare class VFile {
    /**
     * Create a new virtual file.
     *
     * If `options` is `string` or `Buffer`, treats it as `{value: options}`.
     * If `options` is a `VFile`, shallow copies its data over to the new file.
     * All other given fields are set on the newly created `VFile`.
     *
     * Path related properties are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * It’s not possible to set either `dirname` or `extname` without setting
     * either `history`, `path`, `basename`, or `stem` as well.
     *
     * @param {VFileCompatible} [value]
     */
    constructor(value?: VFileCompatible | undefined)
    /**
     * Place to store custom information.
     * It’s OK to store custom data directly on the file, moving it to `data`
     * gives a little more privacy.
     * @type {VFileData}
     */
    data: VFileData_2
    /**
     * List of messages associated with the file.
     * @type {Array<VFileMessage>}
     */
    messages: Array<VFileMessage>
    /**
     * List of file paths the file moved between.
     * @type {Array<string>}
     */
    history: Array<string>
    /**
     * Base of `path`.
     * Defaults to `process.cwd()` (`/` in browsers).
     * @type {string}
     */
    cwd: string
    /**
     * Raw value.
     * @type {VFileValue}
     */
    value: VFileValue
    /**
     * Whether a file was saved to disk.
     * This is used by vfile reporters.
     * @type {boolean}
     */
    stored: boolean
    /**
     * Sometimes files have a non-string representation.
     * This can be stored in the `result` field.
     * One example is when turning markdown into React nodes.
     * This is used by unified to store non-string results.
     * @type {unknown}
     */
    result: unknown
    /**
     * Sometimes files have a source map associated with them.
     * This can be stored in the `map` field.
     * This should be a `RawSourceMap` type from the `source-map` module.
     * @type {Map|undefined}
     */
    map: Map_2 | undefined
    /**
     * Set full path (`~/index.min.js`).
     * Cannot be nullified.
     *
     * @param {string|URL} path
     */
    set path(arg: string)
    /**
     * Access full path (`~/index.min.js`).
     *
     * @returns {string}
     */
    get path(): string
    /**
     * Set parent path (`~`).
     * Cannot be set if there's no `path` yet.
     */
    set dirname(arg: string | undefined)
    /**
     * Access parent path (`~`).
     */
    get dirname(): string | undefined
    /**
     * Set basename (`index.min.js`).
     * Cannot contain path separators.
     * Cannot be nullified either (use `file.path = file.dirname` instead).
     */
    set basename(arg: string | undefined)
    /**
     * Access basename (including extname) (`index.min.js`).
     */
    get basename(): string | undefined
    /**
     * Set extname (including dot) (`.js`).
     * Cannot be set if there's no `path` yet and cannot contain path separators.
     */
    set extname(arg: string | undefined)
    /**
     * Access extname (including dot) (`.js`).
     */
    get extname(): string | undefined
    /**
     * Set stem (w/o extname) (`index.min`).
     * Cannot be nullified, and cannot contain path separators.
     */
    set stem(arg: string | undefined)
    /**
     * Access stem (w/o extname) (`index.min`).
     */
    get stem(): string | undefined
    /**
     * Serialize the file.
     *
     * @param {BufferEncoding} [encoding='utf8'] If `file.value` is a buffer, `encoding` is used to serialize buffers.
     * @returns {string}
     */
    toString(encoding?: BufferEncoding | undefined): string
    /**
     * Create a message and associates it w/ the file.
     *
     * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
     * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
     * @param {string} [origin] Place in code the message originates from (`string`, optional).
     * @returns {VFileMessage}
     */
    message(
    reason: string | Error,
    place?:
    | Node_2<Data>
    | Position_2
    | Point
    | NodeLike_2
    | undefined,
    origin?: string | undefined
    ): VFileMessage
    /**
     * Info: create a message, associate it with the file, and mark the fatality
     * as `null`.
     * Calls `message()` internally.
     *
     * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
     * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
     * @param {string} [origin] Place in code the message originates from (`string`, optional).
     * @returns {VFileMessage}
     */
    info(
    reason: string | Error,
    place?:
    | Node_2<Data>
    | Position_2
    | Point
    | NodeLike_2
    | undefined,
    origin?: string | undefined
    ): VFileMessage
    /**
     * Fail: create a message, associate it with the file, mark the fatality as
     * `true`.
     * Note: fatal errors mean a file is no longer processable.
     * Calls `message()` internally.
     *
     * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
     * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
     * @param {string} [origin] Place in code the message originates from (`string`, optional).
     * @returns {never}
     */
    fail(
    reason: string | Error,
    place?:
    | Node_2<Data>
    | Position_2
    | Point
    | NodeLike_2
    | undefined,
    origin?: string | undefined
    ): never
}

/**
 * Things that can be passed to the constructor.
 */
declare type VFileCompatible = VFileValue | VFileOptions | VFile | URL_3

declare type VFileCoreOptions = {
    value?: VFileValue_2 | undefined
    cwd?: string | undefined
    history?: string[] | undefined
    path?: string | URL_2 | undefined
    basename?: string | undefined
    stem?: string | undefined
    extname?: string | undefined
    dirname?: string | undefined
    data?: VFileData | undefined
}

/**
 * Place to store custom information.
 *
 * Known attributes can be added to @see {@link VFileDataMap}
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
declare type VFileData = Record<string, unknown> & Partial<VFileDataMap>

declare type VFileData_2 = VFileData

/**
 * This map registers the type of the `data` key of a `VFile`.
 *
 * This type can be augmented to register custom `data` types.
 *
 * @example
 * declare module 'vfile' {
 *   interface VFileDataRegistry {
 *     // `file.data.name` is typed as `string`
 *     name: string
 *   }
 * }
 */
// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-empty-interface
declare interface VFileDataMap {}

declare class VFileMessage extends Error {
    /**
     * Constructor of a message for `reason` at `place` from `origin`.
     * When an error is passed in as `reason`, copies the `stack`.
     *
     * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
     * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
     * @param {string} [origin] Place in code the message originates from (`string`, optional).
     */
    constructor(
    reason: string | Error,
    place?:
    | Node_2<Data>
    | Position_2
    | Point
    | NodeLike
    | undefined,
    origin?: string | undefined
    )
    stack: string | undefined
    /**
     * Reason for message.
     * @type {string}
     */
    reason: string
    /**
     * If true, marks associated file as no longer processable.
     * @type {boolean?}
     */
    fatal: boolean | null
    /**
     * Starting line of error.
     * @type {number?}
     */
    line: number | null
    /**
     * Starting column of error.
     * @type {number?}
     */
    column: number | null
    /**
     * Namespace of warning.
     * @type {string?}
     */
    source: string | null
    /**
     * Category of message.
     * @type {string?}
     */
    ruleId: string | null
    /**
     * Full range information, when available.
     * Has start and end properties, both set to an object with line and column, set to number?.
     * @type {Position?}
     */
    position: Position_3 | null
    /**
     * You can use this to specify the source value that’s being reported, which
     * is deemed incorrect.
     * @type {string?}
     */
    actual: string | null
    /**
     * You can use this to suggest values that should be used instead of
     * `actual`, one or more values that are deemed as acceptable.
     * @type {Array<string>?}
     */
    expected: Array<string> | null
    /**
     * You may add a file property with a path of a file (used throughout the VFile ecosystem).
     * @type {string?}
     */
    file: string | null
    /**
     * You may add a url property with a link to documentation for the message.
     * @type {string?}
     */
    url: string | null
    /**
     * You may add a note property with a long form description of the message (supported by vfile-reporter).
     * @type {string?}
     */
    note: string | null
}

/**
 * Configuration: a bunch of keys that will be shallow copied over to the new
 * file.
 */
declare type VFileOptions = {
    [key: string]: unknown
} & VFileCoreOptions

declare type VFileValue = VFileValue_2

/**
 * Contents of the file.
 * Can either be text, or a Buffer like structure.
 * This does not directly use type `Buffer`, because it can also be used in a
 * browser context.
 * Instead this leverages `Uint8Array` which is the base type for `Buffer`,
 * and a native JavaScript construct.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
declare type VFileValue_2 = string | MaybeBuffer

declare type VFileWithOutput<Result> = Result extends Uint8Array // Buffer.
? VFile
: Result extends object // Custom result type
? VFile & {result: Result}
: VFile

export declare interface ViewerProps {
    /**
     * Markdown text
     */
    value: string;
    /**
     * ByteMD plugin list
     */
    plugins?: BytemdPlugin[];
    /**
     * Sanitize strategy: Defaults to GitHub style sanitation with class names allowed
     *
     * https://github.com/syntax-tree/hast-util-sanitize/blob/main/lib/github.json
     *
     * If you want further customization, pass a function to mutate sanitize schema.
     */
    sanitize?: (schema: Schema) => Schema;
}

export { }
