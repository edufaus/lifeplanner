import {
  __commonJS,
  __require
} from "./chunk-4VWTOE5J.js";

// node_modules/twilio-client-mirror/twilio.js
var require_twilio = __commonJS({
  "node_modules/twilio-client-mirror/twilio.js"() {
    (function e(t, n, r) {
      function s(o2, u) {
        if (!n[o2]) {
          if (!t[o2]) {
            var a = typeof __require == "function" && __require;
            if (!u && a)
              return a(o2, true);
            if (i2)
              return i2(o2, true);
            var f = new Error("Cannot find module '" + o2 + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var l = n[o2] = { exports: {} };
          t[o2][0].call(l.exports, function(e2) {
            var n2 = t[o2][1][e2];
            return s(n2 ? n2 : e2);
          }, l, l.exports, e, t, n, r);
        }
        return n[o2].exports;
      }
      var i2 = typeof __require == "function" && __require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    })({ 1: [function(require2, module2, exports2) {
      Twilio = function(loadedTwilio) {
        var Twilio2 = loadedTwilio || function Twilio3() {
        };
        function extend(M) {
          for (var k in M)
            Twilio2[k] = M[k];
        }
        extend(function() {
          var util = require2("./twilio/util");
          var TWILIO_ROOT = typeof TWILIO_ROOT != "undefined" ? TWILIO_ROOT : function() {
            var prot = location.protocol || "http:", uri = "//media.twiliocdn.com/sdk/js/client/", scripts = document.getElementsByTagName("script"), re = RegExp("(\\w+:)?(//.*)v" + util.getPStreamVersion() + "/(twilio.min.js|twilio.js)");
            for (var i2 = 0; i2 < scripts.length; i2++) {
              var match = scripts[i2].src.match(re);
              if (match) {
                prot = match[1] || prot;
                uri = match[2];
                break;
              }
            }
            return prot + uri;
          }();
          util.setTwilioRoot(TWILIO_ROOT);
          var exports3 = require2("./twilio");
          return exports3;
        }());
        return Twilio2;
      }(typeof Twilio !== "undefined" ? Twilio : null);
    }, { "./twilio": 2, "./twilio/util": 19 }], 2: [function(require2, module2, exports2) {
      exports2.Device = require2("./twilio/device").Device;
      exports2.PStream = require2("./twilio/pstream").PStream;
      exports2.Connection = require2("./twilio/connection").Connection;
    }, { "./twilio/connection": 3, "./twilio/device": 4, "./twilio/pstream": 9 }], 3: [function(require2, module2, exports2) {
      var EventEmitter = require2("events").EventEmitter;
      var Exception = require2("./util").Exception;
      var log = require2("./log");
      var Publisher = require2("./eventpublisher");
      var rtc = require2("./rtc");
      var RTCMonitor = require2("./rtc/monitor");
      var twutil = require2("./util");
      var util = require2("util");
      var DTMF_INTER_TONE_GAP = 70;
      var DTMF_PAUSE_DURATION = 500;
      var DTMF_TONE_DURATION = 160;
      var METRICS_BATCH_SIZE = 10;
      var SAMPLES_TO_IGNORE = 20;
      var FEEDBACK_SCORES = [1, 2, 3, 4, 5];
      var FEEDBACK_ISSUES = [
        "one-way-audio",
        "choppy-audio",
        "dropped-call",
        "audio-latency",
        "noisy-call",
        "echo"
      ];
      var WARNING_NAMES = {
        audioOutputLevel: "audio-output-level",
        audioInputLevel: "audio-input-level",
        packetsLostFraction: "packet-loss",
        jitter: "jitter",
        rtt: "rtt",
        mos: "mos"
      };
      var WARNING_PREFIXES = {
        min: "low-",
        max: "high-",
        maxDuration: "constant-"
      };
      function Connection(device, message, options) {
        if (!(this instanceof Connection)) {
          return new Connection(device, message, options);
        }
        twutil.monitorEventEmitter("Twilio.Connection", this);
        this.device = device;
        this.message = message || {};
        options = options || {};
        var defaults = {
          logPrefix: "[Connection]",
          mediaStreamFactory: rtc.PeerConnection,
          offerSdp: null,
          callParameters: {},
          debug: false,
          encrypt: false,
          audioConstraints: device.options["audioConstraints"],
          rtcConstraints: device.options["rtcConstraints"],
          iceServers: device.options["iceServers"]
        };
        for (var prop in defaults) {
          if (prop in options)
            continue;
          options[prop] = defaults[prop];
        }
        this.options = options;
        this.parameters = options.callParameters;
        this._status = this.options["offerSdp"] ? "pending" : "closed";
        this._direction = this.parameters.CallSid ? "INCOMING" : "OUTGOING";
        this.sendHangup = true;
        log.mixinLog(this, this.options["logPrefix"]);
        this.log.enabled = this.options["debug"];
        this.log.warnings = this.options["warnings"];
        function noop() {
        }
        this._onCancel = noop;
        this._onHangup = noop;
        this._onAnswer = function(payload) {
          if (typeof payload.callsid !== "undefined") {
            self.parameters.CallSid = payload.callsid;
            self.mediaStream.callSid = payload.callsid;
          }
        };
        var self = this;
        function createDefaultPayload() {
          var payload = {
            client_name: device._clientName,
            platform: rtc.getMediaEngine(),
            sdk_version: twutil.getReleaseVersion(),
            selected_region: device.options.region
          };
          if (self.parameters.CallSid && !/^TJ/.test(self.parameters.CallSid)) {
            payload.call_sid = self.parameters.CallSid;
          }
          if (self.outboundConnectionId) {
            payload.temp_call_sid = self.outboundConnectionId;
          }
          if (device.stream) {
            if (device.stream.gateway) {
              payload.gateway = device.stream.gateway;
            }
            if (device.stream.region) {
              payload.region = device.stream.region;
            }
          }
          if (self._direction) {
            payload.direction = self._direction;
          }
          return payload;
        }
        var publisher = this._publisher = new Publisher("twilio-js-sdk", device.token, {
          host: device.options.eventgw,
          defaultPayload: createDefaultPayload
        });
        if (options.publishEvents === false) {
          publisher.disable();
        }
        if (this._direction === "INCOMING") {
          publisher.info("connection", "incoming");
        }
        var monitor = this._monitor = new RTCMonitor();
        monitor.disableWarnings();
        var samples = [];
        function createMetricPayload() {
          var payload = {
            call_sid: self.parameters.CallSid,
            client_name: device._clientName,
            sdk_version: twutil.getReleaseVersion(),
            selected_region: device.options.region
          };
          if (device.stream) {
            if (device.stream.gateway) {
              payload.gateway = device.stream.gateway;
            }
            if (device.stream.region) {
              payload.region = device.stream.region;
            }
          }
          if (self._direction) {
            payload.direction = self._direction;
          }
          return payload;
        }
        function publishMetrics() {
          if (samples.length === 0) {
            return;
          }
          publisher.postMetrics("quality-metrics-samples", "metrics-sample", samples.splice(0), createMetricPayload());
        }
        var samplesIgnored = 0;
        monitor.on("sample", function(sample) {
          if (samplesIgnored < SAMPLES_TO_IGNORE) {
            samplesIgnored++;
          } else if (samplesIgnored === SAMPLES_TO_IGNORE) {
            monitor.enableWarnings();
          }
          samples.push(sample);
          if (samples.length >= METRICS_BATCH_SIZE) {
            publishMetrics();
          }
        });
        function formatPayloadForEA(warningData) {
          var payloadData = { threshold: warningData.threshold.value };
          if (warningData.values) {
            payloadData.values = warningData.values.map(function(value) {
              if (typeof value === "number") {
                return Math.round(value * 100) / 100;
              }
              return value;
            });
          } else if (warningData.value) {
            payloadData.value = warningData.value;
          }
          return { data: payloadData };
        }
        function reemitWarning(wasCleared, warningData) {
          var groupPrefix = /^audio/.test(warningData.name) ? "audio-level-" : "network-quality-";
          var groupSuffix = wasCleared ? "-cleared" : "-raised";
          var groupName = groupPrefix + "warning" + groupSuffix;
          var warningPrefix = WARNING_PREFIXES[warningData.threshold.name];
          var warningName = warningPrefix + WARNING_NAMES[warningData.name];
          if (warningName === "constant-audio-input-level" && self.isMuted()) {
            return;
          }
          var level = wasCleared ? "info" : "warning";
          publisher.post(level, groupName, warningName, formatPayloadForEA(warningData));
        }
        monitor.on("warning-cleared", reemitWarning.bind(null, true));
        monitor.on("warning", reemitWarning.bind(null, false));
        this.mediaStream = new this.options["mediaStreamFactory"](this.options["encrypt"], this.device);
        this.mediaStream.oniceconnectionstatechange = function(state) {
          var level = state === "failed" ? "error" : "debug";
          publisher.post(level, "ice-connection-state", state);
        };
        this.mediaStream.onicegatheringstatechange = function(state) {
          publisher.debug("signaling-state", state);
        };
        this.mediaStream.onsignalingstatechange = function(state) {
          publisher.debug("signaling-state", state);
        };
        var self = this;
        this.mediaStream.ondisconnect = function(msg) {
          self.log(msg);
          publisher.warn("network-quality-warning-raised", "ice-connectivity-lost", {
            message: msg
          }, self);
          self.emit("error", {
            code: 31003,
            message: msg,
            info: {
              code: 31003,
              message: msg
            },
            connection: self
          });
        };
        this.mediaStream.onreconnect = function(msg) {
          self.log(msg);
          publisher.info("network-quality-warning-cleared", "ice-connectivity-lost", {
            message: msg
          }, self);
        };
        this.mediaStream.onerror = function(e) {
          if (e.disconnect === true) {
            self._disconnect(e.info && e.info.message);
          }
          var error = {
            code: e.info.code,
            message: e.info.message || "Error with mediastream",
            info: e.info,
            connection: self
          };
          self.log("Received an error from MediaStream:", e);
          self.emit("error", error);
        };
        this.mediaStream.onopen = function() {
          if (self._status === "open") {
            return;
          } else if (self._status === "connecting") {
            self._status = "open";
            self.mediaStream.attachAudio();
            self.emit("accept", self);
          } else {
            self.mediaStream.close();
          }
        };
        this.mediaStream.onclose = function() {
          self._status = "closed";
          if (self.device.sounds.disconnect()) {
            self.device.soundcache.play("disconnect");
          }
          monitor.disable();
          publishMetrics();
          self.emit("disconnect", self);
        };
        this.outboundConnectionId = twutil.generateConnectionUUID();
        this.pstream = this.device.stream;
        this._onCancel = function(payload) {
          var callsid = payload.callsid;
          if (self.parameters.CallSid == callsid) {
            self._status = "closed";
            self.emit("cancel");
            self.pstream.removeListener("cancel", self._onCancel);
          }
        };
        if (this.pstream)
          this.pstream.addListener("cancel", this._onCancel);
        this.on("error", function(error) {
          publisher.error("connection", "error", {
            code: error.code,
            message: error.message
          });
          if (self.pstream && self.pstream.status === "disconnected") {
            cleanupEventListeners(self);
          }
        });
        this.on("disconnect", function() {
          cleanupEventListeners(self);
        });
        return this;
      }
      util.inherits(Connection, EventEmitter);
      Connection.toString = function() {
        return "[Twilio.Connection class]";
      };
      Connection.prototype.toString = function() {
        return "[Twilio.Connection instance]";
      };
      Connection.prototype.sendDigits = function(digits) {
        if (digits.match(/[^0-9*#w]/)) {
          throw new Exception("Illegal character passed into sendDigits");
        }
        var sequence = [];
        for (var i2 = 0; i2 < digits.length; i2++) {
          var dtmf = digits[i2] != "w" ? "dtmf" + digits[i2] : "";
          if (dtmf == "dtmf*")
            dtmf = "dtmfs";
          if (dtmf == "dtmf#")
            dtmf = "dtmfh";
          sequence.push([dtmf, 200, 20]);
        }
        this.device.soundcache.playseq(sequence);
        var dtmfSender = this.mediaStream.getOrCreateDTMFSender();
        function insertDTMF(dtmfs) {
          if (!dtmfs.length) {
            return;
          }
          var dtmf2 = dtmfs.shift();
          if (dtmf2.length) {
            dtmfSender.insertDTMF(dtmf2, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);
          }
          setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);
        }
        if (dtmfSender) {
          if (dtmfSender.canInsertDTMF) {
            this.log("Sending digits using RTCDTMFSender");
            return insertDTMF(digits.split("w"));
          }
          this.log("RTCDTMFSender cannot insert DTMF");
        }
        this.log("Sending digits over PStream");
        if (this.pstream != null && this.pstream.status != "disconnected") {
          var payload = { dtmf: digits, callsid: this.parameters.CallSid };
          this.pstream.publish("dtmf", payload);
        } else {
          var payload = { error: {} };
          var error = {
            code: payload.error.code || 31e3,
            message: payload.error.message || "Could not send DTMF: Signaling channel is disconnected",
            connection: this
          };
          this.emit("error", error);
        }
      };
      Connection.prototype.status = function() {
        return this._status;
      };
      Connection.prototype.mute = function(muteParam) {
        if (arguments.length === 0) {
          this.log.deprecated(".mute() is deprecated. Please use .mute(true) or .mute(false) to mute or unmute a call instead.");
        }
        if (typeof muteParam == "function") {
          return this.addListener("mute", muteParam);
        }
        var wasMuted = this.isMuted();
        var self = this;
        var callback = function() {
          var isMuted = self.isMuted();
          if (wasMuted != isMuted) {
            self._publisher.info("connection", isMuted ? "muted" : "unmuted");
            self.emit("mute", isMuted, self);
          }
        };
        if (muteParam == false) {
          this.mediaStream.attachAudio(callback);
        } else {
          this.mediaStream.detachAudio(callback);
        }
      };
      Connection.prototype.isMuted = function() {
        return !this.mediaStream.isAudioAttached();
      };
      Connection.prototype.unmute = function() {
        this.log.deprecated(".unmute() is deprecated. Please use .mute(false) to unmute a call instead.");
        this.mute(false);
      };
      Connection.prototype.accept = function(handler) {
        if (typeof handler == "function") {
          return this.addListener("accept", handler);
        }
        var audioConstraints = handler || this.options.audioConstraints;
        var self = this;
        this._status = "connecting";
        var connect_ = function(err) {
          if (self._status != "connecting") {
            cleanupEventListeners(self);
            self.mediaStream.close();
            return;
          }
          if (err) {
            if (err.code === 31208) {
              self._publisher.error("get-user-media", "denied", {
                data: {
                  audioConstraints,
                  error: err.error
                }
              });
            } else {
              self._publisher.error("get-user-media", "failed", {
                data: {
                  audioConstraints,
                  error: err.error
                }
              });
            }
            return self._die(err.message, err.code);
          }
          self._publisher.info("get-user-media", "succeeded", {
            data: { audioConstraints }
          });
          var pairs = [];
          for (var key in self.message) {
            pairs.push(encodeURIComponent(key) + "=" + encodeURIComponent(self.message[key]));
          }
          function onLocalAnswer(pc) {
            self._publisher.info("connection", "accepted-by-local");
            self._monitor.enable(pc);
          }
          function onRemoteAnswer(pc) {
            self._publisher.info("connection", "accepted-by-remote");
            self._monitor.enable(pc);
          }
          var params = pairs.join("&");
          if (self._direction === "INCOMING") {
            self.mediaStream.answerIncomingCall.call(self.mediaStream, self.parameters.CallSid, self.options["offerSdp"], self.options.rtcConstraints, self.options.iceServers, onLocalAnswer);
          } else {
            self.pstream.once("answer", self._onAnswer);
            self.mediaStream.makeOutgoingCall.call(self.mediaStream, params, self.outboundConnectionId, self.options.rtcConstraints, self.options.iceServers, onRemoteAnswer);
          }
          self._onHangup = function(payload) {
            if (payload.callsid && (self.parameters.CallSid || self.outboundConnectionId)) {
              if (payload.callsid != self.parameters.CallSid && payload.callsid != self.outboundConnectionId) {
                return;
              }
            } else if (payload.callsid) {
              return;
            }
            self.log("Received HANGUP from gateway");
            if (payload.error) {
              var error = {
                code: payload.error.code || 31e3,
                message: payload.error.message || "Error sent from gateway in HANGUP",
                connection: self
              };
              self.log("Received an error from the gateway:", error);
              self.emit("error", error);
            }
            self.sendHangup = false;
            self._publisher.info("connection", "disconnected-by-remote");
            self._disconnect();
            cleanupEventListeners(self);
          };
          self.pstream.addListener("hangup", self._onHangup);
        };
        this.mediaStream.openHelper(connect_, audioConstraints);
      };
      Connection.prototype.reject = function(handler) {
        if (typeof handler == "function") {
          return this.addListener("reject", handler);
        }
        if (this._status == "pending") {
          var payload = { callsid: this.parameters.CallSid };
          this.pstream.publish("reject", payload);
          this.emit("reject");
          this.mediaStream.reject(this.parameters.CallSid);
          this._publisher.info("connection", "rejected-by-local");
        }
      };
      Connection.prototype.ignore = function(handler) {
        if (typeof handler == "function") {
          return this.addListener("cancel", handler);
        }
        if (this._status == "pending") {
          this._status = "closed";
          this.emit("cancel");
          this.mediaStream.ignore(this.parameters.CallSid);
          this._publisher.info("connection", "ignored-by-local");
        }
      };
      Connection.prototype.cancel = function(handler) {
        this.log.deprecated(".cancel() is deprecated. Please use .ignore() instead.");
        this.ignore(handler);
      };
      Connection.prototype.disconnect = function(handler) {
        if (typeof handler === "function") {
          return this.addListener("disconnect", handler);
        }
        this._publisher.info("connection", "disconnected-by-local");
        this._disconnect();
      };
      Connection.prototype._disconnect = function(message) {
        message = typeof message === "string" ? message : null;
        if (this._status == "open" || this._status == "connecting") {
          this.log("Disconnecting...");
          if (this.pstream != null && this.pstream.status != "disconnected" && this.sendHangup) {
            var callId = this.parameters.CallSid || this.outboundConnectionId;
            if (callId) {
              var payload = { callsid: callId };
              if (message) {
                payload.message = message;
              }
              this.pstream.publish("hangup", payload);
            }
          }
          cleanupEventListeners(this);
          this.mediaStream.close();
        }
      };
      Connection.prototype.error = function(handler) {
        if (typeof handler == "function") {
          return this.addListener("error", handler);
        }
      };
      Connection.prototype._die = function(message, code) {
        this.emit("error", { message, code });
        this._disconnect();
      };
      function cleanupEventListeners(connection) {
        function cleanup() {
          connection.pstream.removeListener("answer", connection._onAnswer);
          connection.pstream.removeListener("cancel", connection._onCancel);
          connection.pstream.removeListener("hangup", connection._onHangup);
        }
        cleanup();
        setTimeout(cleanup, 0);
      }
      exports2.Connection = Connection;
    }, { "./eventpublisher": 5, "./log": 7, "./rtc": 11, "./rtc/monitor": 12, "./util": 19, "events": 21, "util": 37 }], 4: [function(require2, module2, exports2) {
      var EventEmitter = require2("events").EventEmitter;
      var util = require2("util");
      var log = require2("./log");
      var twutil = require2("./util");
      var rtc = require2("./rtc");
      var Options = require2("./options").Options;
      var Sound = require2("./sound").Sound;
      var SoundCache = require2("./soundcache").SoundCache;
      var Connection = require2("./connection").Connection;
      var PStream = require2("./pstream").PStream;
      var REG_INTERVAL = 3e4;
      function Device(token, options) {
        if (!rtc.enabled()) {
          throw new twutil.Exception("twilio.js 1.3 requires WebRTC/ORTC browser support. For more information, see <https://www.twilio.com/docs/api/client/twilio-js>. If you have any questions about this announcement, please contact Twilio Support at <help@twilio.com>.");
        }
        if (!(this instanceof Device)) {
          return new Device(token, options);
        }
        twutil.monitorEventEmitter("Twilio.Device", this);
        if (!token) {
          throw new twutil.Exception("Capability token is not valid or missing.");
        }
        var origOptions = {};
        for (i in options) {
          origOptions[i] = options[i];
        }
        var defaults = {
          logPrefix: "[Device]",
          chunderw: "chunderw-vpc-gll.twilio.com",
          eventgw: "eventgw.twilio.com",
          soundCacheFactory: SoundCache,
          soundFactory: Sound,
          connectionFactory: Connection,
          pStreamFactory: PStream,
          noRegister: false,
          encrypt: false,
          closeProtection: false,
          secureSignaling: true,
          warnings: true,
          audioConstraints: true,
          iceServers: [],
          region: "gll",
          dscp: true,
          sounds: {}
        };
        options = options || {};
        var chunderw = options["chunderw"];
        for (var prop in defaults) {
          if (prop in options)
            continue;
          options[prop] = defaults[prop];
        }
        if (options.dscp) {
          options.rtcConstraints = {
            optional: [
              {
                googDscp: true
              }
            ]
          };
        } else {
          options.rtcConstraints = {};
        }
        this.options = options;
        this.token = token;
        this._status = "offline";
        this._region = "offline";
        this.connections = [];
        this.sounds = new Options({
          incoming: true,
          outgoing: true,
          disconnect: true
        });
        log.mixinLog(this, this.options["logPrefix"]);
        this.log.enabled = this.options["debug"];
        var regions = {
          "gll": "chunderw-vpc-gll.twilio.com",
          "au1": "chunderw-vpc-gll-au1.twilio.com",
          "br1": "chunderw-vpc-gll-br1.twilio.com",
          "ie1": "chunderw-vpc-gll-ie1.twilio.com",
          "jp1": "chunderw-vpc-gll-jp1.twilio.com",
          "sg1": "chunderw-vpc-gll-sg1.twilio.com",
          "us1": "chunderw-vpc-gll-us1.twilio.com"
        };
        var deprecatedRegions = {
          "au": "au1",
          "br": "br1",
          "ie": "ie1",
          "jp": "jp1",
          "sg": "sg1",
          "us-va": "us1",
          "us-or": "us1"
        };
        var region = options["region"].toLowerCase();
        if (region in deprecatedRegions) {
          this.log.deprecated("Region " + region + " is deprecated, please use " + deprecatedRegions[region] + ".");
          region = deprecatedRegions[region];
        }
        if (!(region in regions)) {
          throw new twutil.Exception("Region " + options["region"] + " is invalid. Valid values are: " + Object.keys(regions).join(", "));
        }
        options["chunderw"] = chunderw || regions[region];
        this.soundcache = this.options["soundCacheFactory"]();
        if (typeof document === "undefined")
          var a = {};
        else
          var a = document.createElement("audio");
        canPlayMp3 = false;
        try {
          canPlayMp3 = !!(a.canPlayType && a.canPlayType("audio/mpeg").replace(/no/, ""));
        } catch (e) {
        }
        canPlayVorbis = false;
        try {
          canPlayVorbis = !!(a.canPlayType && a.canPlayType('audio/ogg;codecs="vorbis"').replace(/no/, ""));
        } catch (e) {
        }
        var ext = "mp3";
        if (canPlayVorbis && !canPlayMp3) {
          ext = "ogg";
        }
        var defaultSounds = {
          incoming: { filename: "incoming", loop: true },
          outgoing: { filename: "outgoing", maxDuration: 3e3 },
          disconnect: { filename: "disconnect", maxDuration: 3e3 },
          dtmf1: { filename: "dtmf-1", maxDuration: 1e3 },
          dtmf2: { filename: "dtmf-2", maxDuration: 1e3 },
          dtmf3: { filename: "dtmf-3", maxDuration: 1e3 },
          dtmf4: { filename: "dtmf-4", maxDuration: 1e3 },
          dtmf5: { filename: "dtmf-5", maxDuration: 1e3 },
          dtmf6: { filename: "dtmf-6", maxDuration: 1e3 },
          dtmf7: { filename: "dtmf-7", maxDuration: 1e3 },
          dtmf8: { filename: "dtmf-8", maxDuration: 1e3 },
          dtmf9: { filename: "dtmf-9", maxDuration: 1e3 },
          dtmf0: { filename: "dtmf-0", maxDuration: 1e3 },
          dtmfs: { filename: "dtmf-star", maxDuration: 1e3 },
          dtmfh: { filename: "dtmf-hash", maxDuration: 1e3 }
        };
        var base = twutil.getTwilioRoot() + "sounds/releases/" + twutil.getSoundVersion() + "/";
        for (var name in defaultSounds) {
          var soundDef = defaultSounds[name];
          var sound = this.options.soundFactory(soundDef);
          var defaultUrl = base + soundDef.filename + "." + ext;
          sound.load(defaultUrl);
          this.soundcache.add(name, sound);
        }
        this.soundcache.envelope("incoming", { release: 2e3 });
        var device = this;
        this.addListener("incoming", function(connection) {
          connection.once("accept", function() {
            device.soundcache.stop("incoming");
          });
          connection.once("cancel", function() {
            device.soundcache.stop("incoming");
          });
          connection.once("error", function() {
            device.soundcache.stop("incoming");
          });
          connection.once("reject", function() {
            device.soundcache.stop("incoming");
          });
          if (device.sounds.incoming()) {
            device.soundcache.play("incoming", 0, 1e3);
          }
        });
        this.mediaPresence = { audio: !this.options["noRegister"] };
        this.register(this.token);
        var self = this;
        var closeProtection = this.options["closeProtection"];
        if (closeProtection) {
          var confirmClose = function(event) {
            if (device._status == "busy" || self.connections[0]) {
              var defaultMsg = "A call is currently in-progress. Leaving or reloading this page will end the call.";
              var confirmationMsg = closeProtection == true ? defaultMsg : closeProtection;
              (event || window.event).returnValue = confirmationMsg;
              return confirmationMsg;
            }
          };
          if (typeof window !== "undefined") {
            if (window.addEventListener) {
              window.addEventListener("beforeunload", confirmClose);
            } else if (window.attachEvent) {
              window.attachEvent("onbeforeunload", confirmClose);
            }
          }
        }
        var onClose = function() {
          device.disconnectAll();
        };
        if (typeof window !== "undefined") {
          if (window.addEventListener) {
            window.addEventListener("unload", onClose);
          } else if (window.attachEvent) {
            window.attachEvent("onunload", onClose);
          }
        }
        this.on("error", function() {
        });
        return this;
      }
      util.inherits(Device, EventEmitter);
      function makeConnection(device, params, options) {
        var defaults = {
          publishEvents: device.options.publishEvents,
          debug: device.options.debug,
          encrypt: device.options.encrypt,
          warnings: device.options.warnings
        };
        options = options || {};
        for (var prop in defaults) {
          if (prop in options)
            continue;
          options[prop] = defaults[prop];
        }
        var connection = device.options["connectionFactory"](device, params, options);
        connection.once("accept", function() {
          device._status = "busy";
          device.emit("connect", connection);
        });
        connection.addListener("error", function(error) {
          device.emit("error", error);
          if (connection.status() != "pending" || connection.status() != "connecting")
            return;
          device._removeConnection(connection);
        });
        connection.once("cancel", function() {
          device.log("Canceled: " + connection.parameters["CallSid"]);
          device._removeConnection(connection);
          device.emit("cancel", connection);
        });
        connection.once("disconnect", function() {
          if (device._status == "busy")
            device._status = "ready";
          device.emit("disconnect", connection);
          device._removeConnection(connection);
        });
        connection.once("reject", function() {
          device.log("Rejected: " + connection.parameters["CallSid"]);
          device._removeConnection(connection);
        });
        return connection;
      }
      Device.toString = function() {
        return "[Twilio.Device class]";
      };
      Device.prototype.toString = function() {
        return "[Twilio.Device instance]";
      };
      Device.prototype.register = function(token) {
        var objectized = twutil.objectize(token);
        this._accountSid = objectized.iss;
        this._clientName = objectized.scope["client:incoming"] ? objectized.scope["client:incoming"].params.clientName : null;
        if (this.stream && this.stream.status != "disconnected") {
          this.stream.setToken(token);
        } else {
          this._setupStream();
        }
      };
      Device.prototype.registerPresence = function() {
        if (!this.token) {
          return;
        }
        var tokenIncomingObject = twutil.objectize(this.token).scope["client:incoming"];
        if (tokenIncomingObject) {
          this.mediaPresence.audio = true;
        }
        this._sendPresence();
      };
      Device.prototype.unregisterPresence = function() {
        this.mediaPresence.audio = false;
        this._sendPresence();
      };
      Device.prototype.connect = function(params, audioConstraints) {
        if (typeof params == "function") {
          return this.addListener("connect", params);
        }
        params = params || {};
        audioConstraints = audioConstraints || this.options.audioConstraints;
        var connection = makeConnection(this, params);
        this.connections.push(connection);
        if (this.sounds.outgoing()) {
          var self = this;
          connection.accept(function() {
            self.soundcache.play("outgoing");
          });
        }
        connection.accept(audioConstraints);
        return connection;
      };
      Device.prototype.disconnectAll = function() {
        var connections = [].concat(this.connections);
        for (var i2 = 0; i2 < connections.length; i2++) {
          connections[i2].disconnect();
        }
        if (this.connections.length > 0) {
          this.log("Connections left pending: " + this.connections.length);
        }
      };
      Device.prototype.destroy = function() {
        this._stopRegistrationTimer();
        if (this.stream) {
          this.stream.destroy();
          this.stream = null;
        }
      };
      Device.prototype.disconnect = function(handler) {
        this.addListener("disconnect", handler);
      };
      Device.prototype.incoming = function(handler) {
        this.addListener("incoming", handler);
      };
      Device.prototype.offline = function(handler) {
        this.addListener("offline", handler);
      };
      Device.prototype.ready = function(handler) {
        this.addListener("ready", handler);
      };
      Device.prototype.error = function(handler) {
        this.addListener("error", handler);
      };
      Device.prototype.status = function() {
        return this._status;
      };
      Device.prototype.activeConnection = function() {
        return this.connections[0];
      };
      Device.prototype.region = function() {
        return this._region;
      };
      Device.prototype._sendPresence = function() {
        this.stream.register(this.mediaPresence);
        if (this.mediaPresence.audio) {
          this._startRegistrationTimer();
        } else {
          this._stopRegistrationTimer();
        }
      };
      Device.prototype._startRegistrationTimer = function() {
        clearTimeout(this.regTimer);
        var self = this;
        this.regTimer = setTimeout(function() {
          self._sendPresence();
        }, REG_INTERVAL);
      };
      Device.prototype._stopRegistrationTimer = function() {
        clearTimeout(this.regTimer);
      };
      Device.prototype._setupStream = function() {
        var device = this;
        this.log("Setting up PStream");
        var streamOptions = {
          chunderw: this.options["chunderw"],
          debug: this.options["debug"],
          secureSignaling: this.options["secureSignaling"]
        };
        this.stream = this.options["pStreamFactory"](this.token, streamOptions);
        this.stream.addListener("connected", function(payload) {
          var regions = {
            "US_EAST_VIRGINIA": "us1",
            "US_WEST_OREGON": "us2",
            "ASIAPAC_SYDNEY": "au1",
            "SOUTH_AMERICA_SAO_PAULO": "br1",
            "EU_IRELAND": "ie1",
            "ASIAPAC_TOKYO": "jp1",
            "ASIAPAC_SINGAPORE": "sg1"
          };
          device._region = regions[payload["region"]] || payload["region"];
          device._sendPresence();
        });
        this.stream.addListener("ready", function() {
          device.log("Stream is ready");
          if (device._status == "offline")
            device._status = "ready";
          device.emit("ready", device);
        });
        this.stream.addListener("offline", function() {
          device.log("Stream is offline");
          device._status = "offline";
          device._region = "offline";
          device.emit("offline", device);
        });
        this.stream.addListener("error", function(payload) {
          var error = payload.error;
          if (error) {
            if (payload.callsid) {
              error.connection = device._findConnection(payload.callsid);
            }
            if (error.code === 31205) {
              device._stopRegistrationTimer();
            }
            device.log("Received error: ", error);
            device.emit("error", error);
          }
        });
        this.stream.addListener("invite", function(payload) {
          if (device._status == "busy") {
            device.log("Device busy; ignoring incoming invite");
            return;
          }
          if (!payload["callsid"] || !payload["sdp"]) {
            device.emit("error", { message: "Malformed invite from gateway" });
            return;
          }
          var params = payload.parameters || {};
          params.CallSid = params.CallSid || payload.callsid;
          var connection = makeConnection(device, {}, {
            offerSdp: payload.sdp,
            callParameters: params
          });
          device.connections.push(connection);
          device.emit("incoming", connection);
        });
      };
      Device.prototype._removeConnection = function(connection) {
        for (var i2 = this.connections.length - 1; i2 >= 0; i2--) {
          if (connection == this.connections[i2]) {
            this.connections.splice(i2, 1);
          }
        }
      };
      Device.prototype._findConnection = function(callsid) {
        for (var i2 = 0; i2 < this.connections.length; i2++) {
          var conn = this.connections[i2];
          if (conn.parameters.CallSid == callsid || conn.outboundConnectionId == callsid) {
            return conn;
          }
        }
      };
      function singletonwrapper(cls) {
        var afterSetup = [];
        var tasks = [];
        var queue = function(task) {
          if (cls.instance)
            return task();
          tasks.push(task);
        };
        var defaultErrorHandler = function(error) {
          var err_msg = (error.code ? error.code + ": " : "") + error.message;
          if (cls.instance) {
            var n = 0;
            var listeners = cls.instance.listeners("error");
            for (var i2 = 0; i2 < listeners.length; i2++) {
              if (listeners[i2] !== defaultErrorHandler) {
                n++;
              }
            }
            if (n > 1) {
              return;
            }
            cls.instance.log(err_msg);
          }
          throw new twutil.Exception(err_msg);
        };
        var members = {
          instance: null,
          setup: function(token, options) {
            if (cls.instance) {
              cls.instance.log("Found existing Device; using new token but ignoring options");
              cls.instance.token = token;
              cls.instance.register(token);
            } else {
              cls.instance = new Device(token, options);
              cls.error(defaultErrorHandler);
              cls.sounds = cls.instance.sounds;
              for (var i2 = 0; i2 < tasks.length; i2++) {
                tasks[i2]();
              }
              tasks = [];
            }
            for (var i2 = 0; i2 < afterSetup.length; i2++) {
              afterSetup[i2](token, options);
            }
            afterSetup = [];
            return cls;
          },
          connect: function(parameters, audioConstraints) {
            if (typeof parameters == "function") {
              queue(function() {
                cls.instance.addListener("connect", parameters);
              });
              return;
            }
            if (!cls.instance) {
              throw new twutil.Exception("Run Twilio.Device.setup()");
            }
            if (cls.instance.connections.length > 0) {
              cls.instance.emit("error", { message: "A connection is currently active" });
              return;
            }
            return cls.instance.connect(parameters, audioConstraints);
          },
          disconnectAll: function() {
            queue(function() {
              cls.instance.disconnectAll();
            });
            return cls;
          },
          disconnect: function(handler) {
            queue(function() {
              cls.instance.addListener("disconnect", handler);
            });
            return cls;
          },
          status: function() {
            if (!cls.instance) {
              throw new twutil.Exception("Run Twilio.Device.setup()");
            }
            return cls.instance.status();
          },
          region: function() {
            if (!cls.instance) {
              throw new twutil.Exception("Run Twilio.Device.setup()");
            }
            return cls.instance.region();
          },
          ready: function(handler) {
            queue(function() {
              cls.instance.addListener("ready", handler);
            });
            return cls;
          },
          error: function(handler) {
            queue(function() {
              if (handler != defaultErrorHandler) {
                cls.instance.removeListener("error", defaultErrorHandler);
              }
              cls.instance.addListener("error", handler);
            });
            return cls;
          },
          offline: function(handler) {
            queue(function() {
              cls.instance.addListener("offline", handler);
            });
            return cls;
          },
          incoming: function(handler) {
            queue(function() {
              cls.instance.addListener("incoming", handler);
            });
            return cls;
          },
          destroy: function() {
            if (cls.instance)
              cls.instance.destroy();
            return cls;
          },
          cancel: function(handler) {
            queue(function() {
              cls.instance.addListener("cancel", handler);
            });
            return cls;
          },
          activeConnection: function() {
            if (!cls.instance) {
              return null;
            }
            return cls.instance.activeConnection();
          }
        };
        for (var method in members) {
          cls[method] = members[method];
        }
        return cls;
      }
      Device = singletonwrapper(Device);
      exports2.Device = Device;
    }, { "./connection": 3, "./log": 7, "./options": 8, "./pstream": 9, "./rtc": 11, "./sound": 16, "./soundcache": 17, "./util": 19, "events": 21, "util": 37 }], 5: [function(require2, module2, exports2) {
      "use strict";
      var request = require2("./request");
      function EventPublisher(productName, token, options) {
        if (!(this instanceof EventPublisher)) {
          return new EventPublisher(productName, token, options);
        }
        options = Object.assign({
          defaultPayload: function() {
            return {};
          },
          host: "eventgw.twilio.com"
        }, options);
        var defaultPayload = options.defaultPayload;
        if (typeof defaultPayload !== "function") {
          defaultPayload = function() {
            return Object.assign({}, options.defaultPayload);
          };
        }
        var isEnabled = true;
        Object.defineProperties(this, {
          _defaultPayload: { value: defaultPayload },
          _isEnabled: {
            get: function() {
              return isEnabled;
            },
            set: function(_isEnabled) {
              isEnabled = _isEnabled;
            }
          },
          _host: { value: options.host },
          isEnabled: {
            enumerable: true,
            get: function() {
              return isEnabled;
            }
          },
          productName: { enumerable: true, value: productName },
          token: { enumerable: true, value: token }
        });
      }
      EventPublisher.prototype._post = function _post(endpointName, level, group, name, payload, force) {
        if (!this.isEnabled && !force) {
          return Promise.resolve();
        }
        var event = {
          publisher: this.productName,
          group,
          name,
          timestamp: new Date().toISOString(),
          level: level.toUpperCase(),
          payload_type: "application/json",
          private: false,
          payload: payload && payload.forEach ? payload.slice(0) : Object.assign(this._defaultPayload(), payload)
        };
        var requestParams = {
          url: "https://" + this._host + "/v2/" + endpointName,
          body: event,
          headers: {
            "Content-Type": "application/json",
            "X-Twilio-Token": this.token
          }
        };
        return new Promise(function(resolve, reject) {
          request.post(requestParams, function(err) {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      };
      EventPublisher.prototype.post = function post(level, group, name, payload, force) {
        return this._post("EndpointEvents", level, group, name, payload, force);
      };
      EventPublisher.prototype.debug = function debug(group, name, payload) {
        return this.post("debug", group, name, payload);
      };
      EventPublisher.prototype.info = function info(group, name, payload) {
        return this.post("info", group, name, payload);
      };
      EventPublisher.prototype.warn = function warn(group, name, payload) {
        return this.post("warning", group, name, payload);
      };
      EventPublisher.prototype.error = function error(group, name, payload) {
        return this.post("error", group, name, payload);
      };
      EventPublisher.prototype.postMetrics = function postMetrics(group, name, metrics, customFields) {
        var samples = metrics.map(formatMetric).map(function(sample) {
          return Object.assign(sample, customFields);
        });
        return this._post("EndpointMetrics", "info", group, name, samples);
      };
      EventPublisher.prototype.enable = function enable() {
        this._isEnabled = true;
      };
      EventPublisher.prototype.disable = function disable() {
        this._isEnabled = false;
      };
      function formatMetric(sample) {
        return {
          timestamp: new Date(sample.timestamp).toISOString(),
          total_packets_received: sample.totals.packetsReceived,
          total_packets_lost: sample.totals.packetsLost,
          total_packets_sent: sample.totals.packetsSent,
          total_bytes_received: sample.totals.bytesReceived,
          total_bytes_sent: sample.totals.bytesSent,
          packets_received: sample.packetsReceived,
          packets_lost: sample.packetsLost,
          packets_lost_fraction: sample.packetsLostFraction && Math.round(sample.packetsLostFraction * 100) / 100,
          audio_level_in: sample.audioInputLevel,
          audio_level_out: sample.audioOutputLevel,
          codec_name: sample.codecName,
          local_candidate_address: sample.candidatePair.localAddress,
          local_candidate_id: sample.candidatePair.localCandidateId,
          local_candidate_type: sample.candidatePair.localCandidateType,
          remote_candidate_address: sample.candidatePair.remoteAddress,
          remote_candidate_id: sample.candidatePair.remoteCandidateId,
          remote_candidate_type: sample.candidatePair.remoteCandidateType,
          candidate_transport_type: sample.candidatePair.transportType,
          jitter: sample.jitter,
          rtt: sample.rtt,
          mos: sample.mos && Math.round(sample.mos * 100) / 100
        };
      }
      module2.exports = EventPublisher;
    }, { "./request": 10 }], 6: [function(require2, module2, exports2) {
      function Heartbeat(opts) {
        if (!(this instanceof Heartbeat))
          return new Heartbeat(opts);
        opts = opts || {};
        var noop = function() {
        };
        var defaults = {
          interval: 10,
          now: function() {
            return new Date().getTime();
          },
          repeat: function(f, t) {
            return setInterval(f, t);
          },
          stop: function(f, t) {
            return clearInterval(f, t);
          },
          onsleep: noop,
          onwakeup: noop
        };
        for (var prop in defaults) {
          if (prop in opts)
            continue;
          opts[prop] = defaults[prop];
        }
        this.interval = opts.interval;
        this.lastbeat = 0;
        this.pintvl = null;
        this.onsleep = opts.onsleep;
        this.onwakeup = opts.onwakeup;
        this.repeat = opts.repeat;
        this.stop = opts.stop;
        this.now = opts.now;
      }
      Heartbeat.toString = function() {
        return "[Twilio.Heartbeat class]";
      };
      Heartbeat.prototype.toString = function() {
        return "[Twilio.Heartbeat instance]";
      };
      Heartbeat.prototype.beat = function() {
        this.lastbeat = this.now();
        if (this.sleeping()) {
          if (this.onwakeup) {
            this.onwakeup();
          }
          var self = this;
          this.pintvl = this.repeat.call(null, function() {
            self.check();
          }, this.interval * 1e3);
        }
      };
      Heartbeat.prototype.check = function() {
        var timeidle = this.now() - this.lastbeat;
        if (!this.sleeping() && timeidle >= this.interval * 1e3) {
          if (this.onsleep) {
            this.onsleep();
          }
          this.stop.call(null, this.pintvl);
          this.pintvl = null;
        }
      };
      Heartbeat.prototype.sleeping = function() {
        return this.pintvl == null;
      };
      exports2.Heartbeat = Heartbeat;
    }, {}], 7: [function(require2, module2, exports2) {
      function mixinLog(object, prefix) {
        function log() {
          if (!log.enabled) {
            return;
          }
          var format = log.prefix ? log.prefix + " " : "";
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            log.handler(typeof arg == "string" ? format + arg : arg);
          }
        }
        ;
        function defaultWarnHandler(x) {
          if (typeof console !== "undefined") {
            if (typeof console.warn === "function") {
              console.warn(x);
            } else if (typeof console.log === "function") {
              console.log(x);
            }
          }
        }
        function deprecated() {
          if (!log.warnings) {
            return;
          }
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            log.warnHandler(arg);
          }
        }
        ;
        log.enabled = true;
        log.prefix = prefix || "";
        log.defaultHandler = function(x) {
          typeof console !== "undefined" && console.log(x);
        };
        log.handler = log.defaultHandler;
        log.warnings = true;
        log.defaultWarnHandler = defaultWarnHandler;
        log.warnHandler = log.defaultWarnHandler;
        log.deprecated = deprecated;
        object.log = log;
      }
      exports2.mixinLog = mixinLog;
    }, {}], 8: [function(require2, module2, exports2) {
      var Options = function() {
        function Options2(defaults, assignments) {
          if (!(this instanceof Options2)) {
            return new Options2(defaults);
          }
          this.__dict__ = {};
          defaults = defaults || {};
          assignments = assignments || {};
          for (var name in defaults) {
            this[name] = makeprop(this.__dict__, name);
            this[name](defaults[name]);
          }
          for (var name in assignments) {
            this[name](assignments[name]);
          }
        }
        function makeprop(__dict__, name) {
          return function(value) {
            return typeof value == "undefined" ? __dict__[name] : __dict__[name] = value;
          };
        }
        return Options2;
      }();
      exports2.Options = Options;
    }, {}], 9: [function(require2, module2, exports2) {
      var EventEmitter = require2("events").EventEmitter;
      var util = require2("util");
      var log = require2("./log");
      var twutil = require2("./util");
      var rtc = require2("./rtc");
      var Heartbeat = require2("./heartbeat").Heartbeat;
      var WSTransport = require2("./wstransport").WSTransport;
      function PStream(token, options) {
        if (!(this instanceof PStream)) {
          return new PStream(token, options);
        }
        twutil.monitorEventEmitter("Twilio.PStream", this);
        var defaults = {
          logPrefix: "[PStream]",
          chunderw: "chunderw-vpc-gll.twilio.com",
          secureSignaling: true,
          transportFactory: WSTransport,
          debug: false
        };
        options = options || {};
        for (var prop in defaults) {
          if (prop in options)
            continue;
          options[prop] = defaults[prop];
        }
        this.options = options;
        this.token = token || "";
        this.status = "disconnected";
        this.host = this.options["chunderw"];
        this.gateway = null;
        this.region = null;
        log.mixinLog(this, this.options["logPrefix"]);
        this.log.enabled = this.options["debug"];
        this.on("error", function() {
        });
        var self = this;
        this.addListener("ready", function() {
          self.status = "ready";
        });
        this.addListener("offline", function() {
          self.status = "offline";
        });
        this.addListener("close", function() {
          self.destroy();
        });
        var opt = {
          host: this.host,
          debug: this.options["debug"],
          secureSignaling: this.options["secureSignaling"]
        };
        this.transport = this.options["transportFactory"](opt);
        this.transport.onopen = function() {
          self.status = "connected";
          self.setToken(self.token);
        };
        this.transport.onclose = function() {
          if (self.status != "disconnected") {
            if (self.status != "offline") {
              self.emit("offline", self);
            }
            self.status = "disconnected";
          }
        };
        this.transport.onerror = function(err) {
          self.emit("error", err);
        };
        this.transport.onmessage = function(msg) {
          var objects = twutil.splitObjects(msg.data);
          for (var i2 = 0; i2 < objects.length; i2++) {
            var obj = JSON.parse(objects[i2]);
            var event_type = obj["type"];
            var payload = obj["payload"] || {};
            if (payload["gateway"]) {
              self.gateway = payload["gateway"];
            }
            if (payload["region"]) {
              self.region = payload["region"];
            }
            self.emit(event_type, payload);
          }
        };
        this.transport.open();
        return this;
      }
      util.inherits(PStream, EventEmitter);
      PStream.toString = function() {
        return "[Twilio.PStream class]";
      };
      PStream.prototype.toString = function() {
        return "[Twilio.PStream instance]";
      };
      PStream.prototype.setToken = function(token) {
        this.log("Setting token and publishing listen");
        this.token = token;
        var payload = {
          "token": token,
          "browserinfo": twutil.getSystemInfo()
        };
        this.publish("listen", payload);
      };
      PStream.prototype.register = function(mediaCapabilities) {
        var regPayload = {
          media: mediaCapabilities
        };
        this.publish("register", regPayload);
      };
      PStream.prototype.destroy = function() {
        this.log("Closing PStream");
        this.transport.close();
        return this;
      };
      PStream.prototype.publish = function(type, payload) {
        var msg = JSON.stringify({
          "type": type,
          "version": twutil.getPStreamVersion(),
          "payload": payload
        });
        this.transport.send(msg);
      };
      exports2.PStream = PStream;
    }, { "./heartbeat": 6, "./log": 7, "./rtc": 11, "./util": 19, "./wstransport": 20, "events": 21, "util": 37 }], 10: [function(require2, module2, exports2) {
      "use strict";
      var XHR = typeof XMLHttpRequest === "undefined" ? require2("xmlhttprequest").XMLHttpRequest : XMLHttpRequest;
      function request(method, params, callback) {
        var options = {};
        options.xmlHttpRequestFactory = options.xmlHttpRequestFactory || XHR;
        var xhr = new options.xmlHttpRequestFactory();
        xhr.open(method, params.url, true);
        xhr.onreadystatechange = function onreadystatechange() {
          if (xhr.readyState !== 4) {
            return;
          }
          if (200 <= xhr.status && xhr.status < 300) {
            callback(null, xhr.responseText);
          } else {
            callback(new Error(xhr.responseText));
          }
        };
        for (var headerName in params.headers) {
          xhr.setRequestHeader(headerName, params.headers[headerName]);
        }
        xhr.send(JSON.stringify(params.body));
      }
      var Request = request;
      Request.get = function get(params, callback) {
        return new this("GET", params, callback);
      };
      Request.post = function post(params, callback) {
        return new this("POST", params, callback);
      };
      module2.exports = Request;
    }, { "xmlhttprequest": 39 }], 11: [function(require2, module2, exports2) {
      var PeerConnection = require2("./peerconnection");
      function enabled(set) {
        if (typeof set !== "undefined") {
          PeerConnection.enabled = set;
        }
        return PeerConnection.enabled;
      }
      function getMediaEngine() {
        return typeof RTCIceGatherer !== "undefined" ? "ORTC" : "WebRTC";
      }
      module2.exports = {
        enabled,
        getMediaEngine,
        PeerConnection
      };
    }, { "./peerconnection": 14 }], 12: [function(require2, module2, exports2) {
      "use strict";
      var EventEmitter = require2("events").EventEmitter;
      var getStatistics = require2("./stats");
      var inherits = require2("util").inherits;
      var Mos = require2("./mos");
      var SAMPLE_COUNT_METRICS = 5;
      var SAMPLE_COUNT_CLEAR = 0;
      var SAMPLE_COUNT_RAISE = 3;
      var SAMPLE_INTERVAL = 1e3;
      var WARNING_TIMEOUT = 5 * 1e3;
      var DEFAULT_THRESHOLDS = {
        audioInputLevel: { maxDuration: 10 },
        audioOutputLevel: { maxDuration: 10 },
        packetsLostFraction: { max: 1 },
        jitter: { max: 30 },
        rtt: { max: 400 },
        mos: { min: 3 }
      };
      function RTCMonitor(options) {
        if (!(this instanceof RTCMonitor)) {
          return new RTCMonitor(options);
        }
        options = options || {};
        var thresholds = Object.assign({}, DEFAULT_THRESHOLDS, options.thresholds);
        Object.defineProperties(this, {
          _activeWarnings: { value: /* @__PURE__ */ new Map() },
          _currentStreaks: { value: /* @__PURE__ */ new Map() },
          _peerConnection: { value: options.peerConnection, writable: true },
          _sampleBuffer: { value: [] },
          _sampleInterval: { value: null, writable: true },
          _thresholds: { value: thresholds },
          _warningsEnabled: { value: true, writable: true }
        });
        if (options.peerConnection) {
          this.enable();
        }
        EventEmitter.call(this);
      }
      inherits(RTCMonitor, EventEmitter);
      RTCMonitor.createSample = function createSample(stats, previousSample) {
        var previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;
        var previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;
        var previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;
        var currentPacketsSent = stats.packetsSent - previousPacketsSent;
        var currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;
        var currentPacketsLost = stats.packetsLost - previousPacketsLost;
        var currentInboundPackets = currentPacketsReceived + currentPacketsLost;
        var currentPacketsLostFraction = currentInboundPackets > 0 ? currentPacketsLost / currentInboundPackets * 100 : 100;
        var totalInboundPackets = stats.packetsReceived + stats.packetsLost;
        var totalPacketsLostFraction = totalInboundPackets > 0 ? stats.packetsLost / totalInboundPackets * 100 : 100;
        return {
          timestamp: stats.timestamp,
          totals: {
            packetsReceived: stats.packetsReceived,
            packetsLost: stats.packetsLost,
            packetsSent: stats.packetsSent,
            packetsLostFraction: totalPacketsLostFraction,
            bytesReceived: stats.bytesReceived,
            bytesSent: stats.bytesSent
          },
          candidatePair: {
            localAddress: stats.localAddress,
            localCandidateId: stats.localCandidateId,
            localCandidateType: stats.localCandidateType,
            remoteAddress: stats.remoteAddress,
            remoteCandidateId: stats.remoteCandidateId,
            remoteCandidateType: stats.remoteCandidateType,
            transportType: stats.transportType
          },
          packetsSent: currentPacketsSent,
          packetsReceived: currentPacketsReceived,
          packetsLost: currentPacketsLost,
          packetsLostFraction: currentPacketsLostFraction,
          audioInputLevel: stats.audioInputLevel,
          audioOutputLevel: stats.audioOutputLevel,
          codecName: stats.codecName,
          jitter: stats.jitter,
          rtt: stats.rtt,
          mos: Mos.calculate(stats, previousSample && currentPacketsLostFraction)
        };
      };
      RTCMonitor.prototype.enable = function enable(peerConnection) {
        if (peerConnection) {
          if (this._peerConnection && peerConnection !== this._peerConnection) {
            throw new Error("Attempted to replace an existing PeerConnection in RTCMonitor.enable");
          }
          this._peerConnection = peerConnection;
        }
        if (!this._peerConnection) {
          throw new Error("Can not enable RTCMonitor without a PeerConnection");
        }
        this._sampleInterval = this._sampleInterval || setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);
        return this;
      };
      RTCMonitor.prototype.disable = function disable() {
        clearInterval(this._sampleInterval);
        this._sampleInterval = null;
        return this;
      };
      RTCMonitor.prototype.getSample = function getSample() {
        var pc = this._peerConnection;
        var self = this;
        return new Promise(function(resolve, reject) {
          getStatistics(pc, function(error, stats) {
            if (error) {
              reject(error);
            } else {
              var previousSample = self._sampleBuffer.length && self._sampleBuffer[self._sampleBuffer.length - 1];
              resolve(RTCMonitor.createSample(stats, previousSample));
            }
          });
        });
      };
      RTCMonitor.prototype._fetchSample = function _fetchSample(sample) {
        var self = this;
        return this.getSample().then(function addSample(sample2) {
          self._addSample(sample2);
          self._raiseWarnings();
          self.emit("sample", sample2);
          return sample2;
        }, function getSampleFailed(error) {
          self.disable();
          self.emit("error", error);
        });
      };
      RTCMonitor.prototype._addSample = function _addSample(sample) {
        var samples = this._sampleBuffer;
        samples.push(sample);
        if (samples.length > SAMPLE_COUNT_METRICS) {
          samples.splice(0, samples.length - SAMPLE_COUNT_METRICS);
        }
      };
      RTCMonitor.prototype._raiseWarnings = function _raiseWarnings() {
        if (!this._warningsEnabled) {
          return;
        }
        for (var name in this._thresholds) {
          this._raiseWarningsForStat(name);
        }
      };
      RTCMonitor.prototype.enableWarnings = function enableWarnings() {
        this._warningsEnabled = true;
        return this;
      };
      RTCMonitor.prototype.disableWarnings = function disableWarnings() {
        if (this._warningsEnabled) {
          this._activeWarnings.clear();
        }
        this._warningsEnabled = false;
        return this;
      };
      RTCMonitor.prototype._raiseWarningsForStat = function _raiseWarningsForStat(statName) {
        var samples = this._sampleBuffer;
        var limits = this._thresholds[statName];
        var relevantSamples = samples.slice(-SAMPLE_COUNT_METRICS);
        var values = relevantSamples.map(function(sample) {
          return sample[statName];
        });
        var containsNull = values.some(function(value) {
          return typeof value === "undefined" || value === null;
        });
        if (containsNull) {
          return;
        }
        if (typeof limits.max === "number") {
          var count = countHigh(limits.max, values);
          if (count >= SAMPLE_COUNT_RAISE) {
            this._raiseWarning(statName, "max", { values });
          } else if (count <= SAMPLE_COUNT_CLEAR) {
            this._clearWarning(statName, "max", { values });
          }
        }
        if (typeof limits.min === "number") {
          var count = countLow(limits.min, values);
          if (count >= SAMPLE_COUNT_RAISE) {
            this._raiseWarning(statName, "min", { values });
          } else if (count <= SAMPLE_COUNT_CLEAR) {
            this._clearWarning(statName, "min", { values });
          }
        }
        if (typeof limits.maxDuration === "number" && samples.length > 1) {
          relevantSamples = samples.slice(-2);
          var prevValue = relevantSamples[0][statName];
          var curValue = relevantSamples[1][statName];
          var prevStreak = this._currentStreaks.get(statName) || 0;
          var streak = prevValue === curValue ? prevStreak + 1 : 0;
          this._currentStreaks.set(statName, streak);
          if (streak >= limits.maxDuration) {
            this._raiseWarning(statName, "maxDuration", { value: streak });
          } else if (streak === 0) {
            this._clearWarning(statName, "maxDuration", { value: prevStreak });
          }
        }
      };
      function countLow(min, values) {
        return values.reduce(function(lowCount, value) {
          return lowCount += value < min ? 1 : 0;
        }, 0);
      }
      function countHigh(max, values) {
        return values.reduce(function(highCount, value) {
          return highCount += value > max ? 1 : 0;
        }, 0);
      }
      RTCMonitor.prototype._clearWarning = function _clearWarning(statName, thresholdName, data) {
        var warningId = statName + ":" + thresholdName;
        var activeWarning = this._activeWarnings.get(warningId);
        if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) {
          return;
        }
        this._activeWarnings.delete(warningId);
        this.emit("warning-cleared", Object.assign({
          name: statName,
          threshold: {
            name: thresholdName,
            value: this._thresholds[statName][thresholdName]
          }
        }, data));
      };
      RTCMonitor.prototype._raiseWarning = function _raiseWarning(statName, thresholdName, data) {
        var warningId = statName + ":" + thresholdName;
        if (this._activeWarnings.has(warningId)) {
          return;
        }
        this._activeWarnings.set(warningId, { timeRaised: Date.now() });
        this.emit("warning", Object.assign({
          name: statName,
          threshold: {
            name: thresholdName,
            value: this._thresholds[statName][thresholdName]
          }
        }, data));
      };
      module2.exports = RTCMonitor;
    }, { "./mos": 13, "./stats": 15, "events": 21, "util": 37 }], 13: [function(require2, module2, exports2) {
      var rfactorConstants = {
        r0: 94.768,
        is: 1.42611
      };
      function calcMos(sample, fractionLost) {
        if (!sample || typeof sample.rtt !== "number" || typeof sample.jitter !== "number" || typeof sample.packetsLost !== "number" || typeof fractionLost !== "number") {
          return null;
        }
        var rFactor = calculateRFactor(sample.rtt, sample.jitter, fractionLost);
        var mos = 1 + 0.035 * rFactor + 7e-6 * rFactor * (rFactor - 60) * (100 - rFactor);
        var isValid = mos >= 1 && mos < 4.6;
        return isValid ? mos : null;
      }
      function calculateRFactor(rtt, jitter, fractionLost) {
        var effectiveLatency = rtt + jitter * 2 + 10;
        var rFactor = 0;
        switch (true) {
          case effectiveLatency < 160:
            rFactor = rfactorConstants.r0 - effectiveLatency / 40;
            break;
          case effectiveLatency < 1e3:
            rFactor = rfactorConstants.r0 - (effectiveLatency - 120) / 10;
            break;
          case effectiveLatency >= 1e3:
            rFactor = rfactorConstants.r0 - effectiveLatency / 100;
            break;
        }
        var multiplier = 0.01;
        switch (true) {
          case fractionLost === -1:
            multiplier = 0;
            rFactor = 0;
            break;
          case fractionLost <= rFactor / 2.5:
            multiplier = 2.5;
            break;
          case (fractionLost > rFactor / 2.5 && fractionLost < 100):
            multiplier = 0.25;
            break;
        }
        rFactor = rFactor - fractionLost * multiplier;
        return rFactor;
      }
      module2.exports = {
        calculate: calcMos
      };
    }, {}], 14: [function(require2, module2, exports2) {
      var log = require2("../log");
      var ortcAdapter = require2("ortc-adapter");
      var stackTrace = require2("stacktrace-js");
      var StateMachine = require2("../statemachine");
      var util = require2("../util");
      var ICE_CONNECTION_STATES = {
        "new": [
          "checking",
          "closed"
        ],
        "checking": [
          "new",
          "connected",
          "failed",
          "closed",
          "completed"
        ],
        "connected": [
          "new",
          "disconnected",
          "completed",
          "closed"
        ],
        "completed": [
          "new",
          "disconnected",
          "closed",
          "completed"
        ],
        "failed": [
          "new",
          "disconnected",
          "closed"
        ],
        "disconnected": [
          "connected",
          "completed",
          "failed",
          "closed"
        ],
        "closed": []
      };
      var INITIAL_ICE_CONNECTION_STATE = "new";
      var SIGNALING_STATES = {
        "stable": [
          "have-local-offer",
          "have-remote-offer",
          "closed"
        ],
        "have-local-offer": [
          "stable",
          "closed"
        ],
        "have-remote-offer": [
          "stable",
          "closed"
        ],
        "closed": []
      };
      var INITIAL_SIGNALING_STATE = "stable";
      function PeerConnection(encrypt, device) {
        if (!(this instanceof PeerConnection))
          return new PeerConnection(encrypt, device);
        var noop = function() {
        };
        this.onopen = noop;
        this.onerror = noop;
        this.onclose = noop;
        this.ondisconnect = noop;
        this.onreconnect = noop;
        this.onsignalingstatechange = noop;
        this.oniceconnectionstatechange = noop;
        this.onicecandidate = noop;
        this.version = null;
        this.pstream = device.stream;
        this.stream = null;
        this.video = typeof document !== "undefined" && document.createElement("video");
        this.video.autoplay = "autoplay";
        this.device = device;
        this.status = "connecting";
        this.callSid = null;
        this._dtmfSender = null;
        this._dtmfSenderUnsupported = false;
        this._callEvents = [];
        this._nextTimeToPublish = Date.now();
        this._onAnswer = noop;
        log.mixinLog(this, "[Twilio.PeerConnection]");
        this.log.enabled = this.device.options["debug"];
        this.log.warnings = this.device.options["warnings"];
        this._iceConnectionStateMachine = new StateMachine(ICE_CONNECTION_STATES, INITIAL_ICE_CONNECTION_STATE);
        this._signalingStateMachine = new StateMachine(SIGNALING_STATES, INITIAL_SIGNALING_STATE);
        return this;
      }
      PeerConnection.prototype.uri = function() {
        return this._uri;
      };
      PeerConnection.prototype.openHelper = function(next, audioConstraints) {
        var self = this;
        function onSuccess(stream) {
          self.stream = stream;
          next();
        }
        function onFailure(error) {
          if (error.code && error.code === error.PERMISSION_DENIED || error.name && error.name === "PermissionDeniedError") {
            next({
              error,
              message: "User denied access to microphone, or the web browser did not allow microphone access at this address.",
              code: 31208
            });
          } else {
            next({
              error,
              message: "Error occurred while accessing microphone: " + error.name + (error.message ? " (" + error.message + ")" : ""),
              code: 31201
            });
          }
        }
        PeerConnection.getUserMedia({ audio: audioConstraints }, onSuccess, onFailure);
      };
      PeerConnection.prototype._setupPeerConnection = function(rtcConstraints, iceServers) {
        var version = PeerConnection.protocol;
        version.create(this.log, rtcConstraints, iceServers);
        version.pc.addStream(this.stream);
        var self = this;
        version.pc.onaddstream = function(ev) {
          if (typeof self.video.srcObject !== "undefined") {
            self.video.srcObject = ev.stream;
          } else if (typeof self.video.mozSrcObject !== "undefined") {
            self.video.mozSrcObject = ev.stream;
          } else if (typeof self.video.src !== "undefined") {
            var url = window.URL || window.webkitURL;
            self.video.src = url.createObjectURL(ev.stream);
          } else {
            self.log("Error attaching stream to element.");
          }
        };
        return version;
      };
      PeerConnection.prototype._setupChannel = function() {
        var self = this;
        var pc = this.version.pc;
        self.version.pc.onopen = function() {
          self.status = "open";
          self.onopen();
        };
        self.version.pc.onstatechange = function(stateEvent) {
          if (self.version.pc && self.version.pc.readyState == "stable") {
            self.status = "open";
            self.onopen();
          }
        };
        self.version.pc.onsignalingstatechange = function(signalingEvent) {
          var state = pc.signalingState;
          self.log('signalingState is "' + state + '"');
          try {
            self._signalingStateMachine.transition(state);
          } catch (error) {
          }
          if (self.version.pc && self.version.pc.signalingState == "stable") {
            self.status = "open";
            self.onopen();
          }
          self.onsignalingstatechange(pc.signalingState);
        };
        pc.onicecandidate = function onicecandidate(event) {
          self.onicecandidate(event.candidate);
        };
        pc.oniceconnectionstatechange = function() {
          var state = pc.iceConnectionState;
          var previousState = self._iceConnectionStateMachine.currentState;
          try {
            self._iceConnectionStateMachine.transition(state);
          } catch (error) {
          }
          switch (state) {
            case "connected":
              if (previousState === "disconnected") {
                var message = "ICE liveliness check succeeded. Connection with Twilio restored";
                self.log(message);
                self.onreconnect(message);
              }
              break;
            case "disconnected":
              var message = "ICE liveliness check failed. May be having trouble connecting to Twilio";
              self.log(message);
              self.ondisconnect(message);
              break;
            case "failed":
              var message = (previousState === "checking" ? "ICE negotiation with Twilio failed." : "Connection with Twilio was interrupted.") + " Call will terminate.";
              self.log(message);
              self.onerror({
                info: {
                  code: 31003,
                  message
                },
                disconnect: true
              });
              break;
            default:
              self.log('iceConnectionState is "' + state + '"');
          }
          self.oniceconnectionstatechange(state);
        };
      };
      PeerConnection.prototype._initializeMediaStream = function(rtcConstraints, iceServers) {
        if (this.status == "open") {
          return false;
        }
        if (this.pstream.status == "disconnected") {
          this.onerror({ info: { code: 31e3, message: "Cannot establish connection. Client is disconnected" } });
          this.close();
          return false;
        }
        this.version = this._setupPeerConnection(rtcConstraints, iceServers);
        this._setupChannel();
        return true;
      };
      PeerConnection.prototype.makeOutgoingCall = function(params, callsid, rtcConstraints, iceServers, onMediaStarted) {
        if (!this._initializeMediaStream(rtcConstraints, iceServers)) {
          return;
        }
        var self = this;
        this.callSid = callsid;
        var onAnswerSuccess = function() {
          onMediaStarted(self.version.pc);
        };
        var onAnswerError = function(err) {
          var errMsg = err.message || err;
          self.onerror({ info: { code: 31e3, message: "Error processing answer: " + errMsg } });
        };
        this._onAnswer = function(payload) {
          if (self.status != "closed") {
            self.version.processAnswer(payload.sdp, onAnswerSuccess, onAnswerError);
          }
        };
        this.pstream.once("answer", this._onAnswer);
        var onOfferSuccess = function() {
          if (self.status != "closed") {
            self.pstream.publish("invite", {
              sdp: self.version.getSDP(),
              callsid: self.callSid,
              twilio: {
                params
              }
            });
          }
        };
        var onOfferError = function(err) {
          var errMsg = err.message || err;
          self.onerror({ info: { code: 31e3, message: "Error creating the offer: " + errMsg } });
        };
        this.version.createOffer({ audio: true }, onOfferSuccess, onOfferError);
      };
      PeerConnection.prototype.answerIncomingCall = function(callSid, sdp, rtcConstraints, iceServers, onMediaStarted) {
        if (!this._initializeMediaStream(rtcConstraints, iceServers)) {
          return;
        }
        this.callSid = callSid;
        var self = this;
        var onAnswerSuccess = function() {
          if (self.status != "closed") {
            self.pstream.publish("answer", {
              callsid: callSid,
              sdp: self.version.getSDP()
            });
            onMediaStarted(self.version.pc);
          }
        };
        var onAnswerError = function(err) {
          var errMsg = err.message || err;
          self.onerror({ info: { code: 31e3, message: "Error creating the answer: " + errMsg } });
        };
        this.version.processSDP(sdp, { audio: true }, onAnswerSuccess, onAnswerError);
      };
      PeerConnection.prototype.close = function() {
        if (this.version && this.version.pc) {
          if (this.version.pc.signalingState !== "closed") {
            this.version.pc.close();
          }
          this.version.pc = null;
        }
        if (this.stream) {
          stopStream(this.stream);
          this.stream = null;
        }
        if (this.pstream) {
          this.pstream.removeListener("answer", this._onAnswer);
        }
        this.video.src = "";
        this.status = "closed";
        this.onclose();
      };
      PeerConnection.prototype.reject = function(callSid) {
        this.callSid = callSid;
      };
      PeerConnection.prototype.ignore = function(callSid) {
        this.callSid = callSid;
      };
      PeerConnection.prototype.attachAudio = function(callback) {
        if (this.stream) {
          var audioTracks = typeof this.stream.getAudioTracks === "function" ? this.stream.getAudioTracks() : this.stream.audioTracks;
          audioTracks[0].enabled = true;
        }
        if (callback && typeof callback == "function") {
          callback();
        }
      };
      PeerConnection.prototype.detachAudio = function(callback) {
        if (this.stream) {
          var audioTracks = typeof this.stream.getAudioTracks === "function" ? this.stream.getAudioTracks() : this.stream.audioTracks;
          audioTracks[0].enabled = false;
        }
        if (callback && typeof callback == "function") {
          callback();
        }
      };
      PeerConnection.prototype.isAudioAttached = function() {
        if (this.stream) {
          var audioTracks = typeof this.stream.getAudioTracks === "function" ? this.stream.getAudioTracks() : this.stream.audioTracks;
          return audioTracks[0].enabled;
        }
        return false;
      };
      PeerConnection.getUserMedia = function getUserMedia(constraints, successCallback, errorCallback) {
        if (typeof navigator == "undefined")
          return;
        if (typeof navigator.webkitGetUserMedia == "function") {
          navigator.webkitGetUserMedia(constraints, successCallback, errorCallback);
        } else if (typeof navigator.mozGetUserMedia == "function") {
          navigator.mozGetUserMedia(constraints, successCallback, errorCallback);
        } else if (typeof navigator.getUserMedia === "function") {
          navigator.getUserMedia(constraints, successCallback, errorCallback);
        } else {
          this.log("No getUserMedia() implementation available");
        }
      };
      PeerConnection.prototype.getOrCreateDTMFSender = function getOrCreateDTMFSender() {
        if (this._dtmfSender) {
          return this._dtmfSender;
        } else if (this._dtmfSenderUnsupported) {
          return null;
        }
        var pc = this.version.pc;
        if (!pc) {
          this.log("No RTCPeerConnection available to call createDTMFSender on");
          return null;
        }
        if (typeof pc.createDTMFSender !== "function") {
          this.log("RTCPeerConnection does not support createDTMFSender");
          this._dtmfSenderUnsupported = true;
          return null;
        }
        var streams = pc.getLocalStreams();
        var stream;
        var tracks;
        var track;
        for (var i2 = 0; i2 < streams.length; i2++) {
          stream = streams[i2];
          tracks = typeof stream.getAudioTracks === "function" ? stream.getAudioTracks() : stream.audioTracks;
          if (tracks.length) {
            track = tracks[0];
            break;
          }
        }
        if (!track) {
          this.log("No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender");
          return null;
        }
        this.log("Creating RTCDTMFSender");
        var dtmfSender = pc.createDTMFSender(track);
        this._dtmfSender = dtmfSender;
        return dtmfSender;
      };
      var RTCPC = function() {
        if (typeof window == "undefined")
          return;
        if (typeof window.webkitRTCPeerConnection == "function") {
          this.RTCPeerConnection = webkitRTCPeerConnection;
        } else if (typeof window.mozRTCPeerConnection == "function") {
          this.RTCPeerConnection = mozRTCPeerConnection;
          RTCSessionDescription = mozRTCSessionDescription;
          RTCIceCandidate = mozRTCIceCandidate;
        } else if (typeof RTCIceGatherer !== "undefined") {
          this.RTCPeerConnection = ortcAdapter.RTCPeerConnection;
          RTCSessionDescription = ortcAdapter.RTCSessionDescription;
          RTCIceCandidate = ortcAdapter.RTCIceCandidate;
        } else {
          this.log("No RTCPeerConnection implementation available");
        }
      };
      RTCPC.prototype.create = function(log2, rtcConstraints, iceServers) {
        this.log = log2;
        this.pc = new this.RTCPeerConnection({ iceServers }, rtcConstraints);
      };
      RTCPC.prototype.createModernConstraints = function(c) {
        if (typeof c === "undefined") {
          return null;
        }
        var nc = {};
        if (typeof webkitRTCPeerConnection !== "undefined") {
          nc.mandatory = {};
          if (typeof c.audio !== "undefined") {
            nc.mandatory.OfferToReceiveAudio = c.audio;
          }
          if (typeof c.video !== "undefined") {
            nc.mandatory.OfferToReceiveVideo = c.video;
          }
        } else {
          if (typeof c.audio !== "undefined") {
            nc.offerToReceiveAudio = c.audio;
          }
          if (typeof c.video !== "undefined") {
            nc.offerToReceiveVideo = c.video;
          }
        }
        return nc;
      };
      RTCPC.prototype.createOffer = function(constraints, onSuccess, onError) {
        var self = this;
        var success = function(sd) {
          if (self.pc) {
            self.pc.setLocalDescription(new RTCSessionDescription(sd), onSuccess, onError);
          }
        };
        this.pc.createOffer(success, onError, this.createModernConstraints(constraints));
      };
      RTCPC.prototype.createAnswer = function(constraints, onSuccess, onError) {
        var self = this;
        var success = function(sd) {
          if (self.pc) {
            self.pc.setLocalDescription(new RTCSessionDescription(sd), onSuccess, onError);
          }
        };
        this.pc.createAnswer(success, onError, this.createModernConstraints(constraints));
      };
      RTCPC.prototype.processSDP = function(sdp, constraints, onSuccess, onError) {
        var self = this;
        var success = function() {
          self.createAnswer(constraints, onSuccess, onError);
        };
        this.pc.setRemoteDescription(new RTCSessionDescription({ sdp, type: "offer" }), success, onError);
      };
      RTCPC.prototype.getSDP = function() {
        return this.pc.localDescription.sdp;
      };
      RTCPC.prototype.processAnswer = function(sdp, onSuccess, onError) {
        if (!this.pc) {
          return;
        }
        this.pc.setRemoteDescription(new RTCSessionDescription({ sdp, type: "answer" }), onSuccess, onError);
      };
      RTCPC.test = function() {
        if (typeof navigator == "object") {
          if (navigator.webkitGetUserMedia && typeof window.webkitRTCPeerConnection == "function") {
            return true;
          } else if (navigator.mozGetUserMedia && typeof window.mozRTCPeerConnection == "function") {
            try {
              var test = new window.mozRTCPeerConnection();
              if (typeof test.getLocalStreams !== "function")
                return false;
            } catch (e) {
              return false;
            }
            return true;
          } else if (typeof RTCIceGatherer !== "undefined") {
            return true;
          }
        }
      };
      PeerConnection.protocol = function() {
        if (RTCPC.test())
          return new RTCPC();
        else
          return null;
      }();
      PeerConnection.enabled = !!PeerConnection.protocol;
      function stopStream(stream) {
        if (typeof MediaStreamTrack.prototype.stop === "function") {
          var audioTracks = typeof stream.getAudioTracks === "function" ? stream.getAudioTracks() : stream.audioTracks;
          audioTracks.forEach(function(track) {
            track.stop();
          });
        } else {
          stream.stop();
        }
      }
      module2.exports = PeerConnection;
    }, { "../log": 7, "../statemachine": 18, "../util": 19, "ortc-adapter": 22, "stacktrace-js": 34 }], 15: [function(require2, module2, exports2) {
      function getStatistics(peerConnection, callback) {
        var error = new Error("WebRTC statistics are unsupported");
        if (!peerConnection) {
          callback(new Error("PeerConnection is null"));
        } else if (typeof navigator === "undefined" || typeof peerConnection.getStats !== "function") {
          callback(error);
        } else if (navigator.webkitGetUserMedia) {
          peerConnection.getStats(chainCallback(withStats, callback), callback);
        } else if (navigator.mozGetUserMedia) {
          peerConnection.getStats(null, chainCallback(mozWithStats, callback), callback);
        } else {
          callback(error);
        }
      }
      function withStats(response, callback) {
        var knownStats = [];
        var unknownStats = [];
        var results = response.result();
        results.forEach(function(report) {
          var processedReport = null;
          switch (report.type) {
            case "googCandidatePair":
              processedReport = processCandidatePair(report);
              break;
            case "ssrc":
              processedReport = processSSRC(report);
              break;
            default:
              unknownStats.push(report);
          }
          if (processedReport) {
            knownStats.push(processedReport);
          }
        });
        if (knownStats.length === 0 || (knownStats = filterKnownStats(knownStats)).length === 0) {
          return callback(null, {});
        }
        var mergedStats = knownStats.reduceRight(function(mergedStat, knownStat) {
          for (var name in knownStat) {
            mergedStat[name] = knownStat[name];
          }
          return mergedStat;
        }, {});
        callback(null, mergedStats);
      }
      function processCandidatePair(report) {
        var knownStats = {};
        var unknownStats = {};
        var names = report.names();
        var timestamp = report.timestamp ? Number(report.timestamp) : null;
        for (var i2 = 0; i2 < names.length; i2++) {
          var name = names[i2];
          var value = report.stat(name);
          switch (name) {
            case "googActiveConnection":
              if (value !== "true") {
                return null;
              }
              break;
            case "googLocalAddress":
              knownStats["localAddress"] = value;
              break;
            case "googRemoteAddress":
              knownStats["remoteAddress"] = value;
              break;
            case "googLocalCandidateType":
              knownStats["localCandidateType"] = value;
              break;
            case "googRemoteCandidateType":
              knownStats["remoteCandidateType"] = value;
              break;
            case "googTransportType":
              knownStats["transportType"] = value;
              break;
            case "localCandidateId":
              knownStats["localCandidateId"] = value;
              break;
            case "remoteCandidateId":
              knownStats["remoteCandidateId"] = value;
              break;
            case "googRtt":
              knownStats["rtt"] = Number(value);
              break;
            case "":
              break;
            default:
              unknownStats[name] = value;
          }
        }
        knownStats.timestamp = timestamp;
        return packageStats(knownStats, unknownStats);
      }
      function processSSRC(report) {
        var knownStats = {};
        var unknownStats = {};
        var names = report.names();
        var timestamp = report.timestamp ? Number(report.timestamp) : null;
        names.forEach(function(name) {
          var value = report.stat(name);
          switch (name) {
            case "googCodecName":
              var codecName = value;
              if (codecName !== "") {
                knownStats["codecName"] = value;
              }
              break;
            case "googJitterBufferMs":
              knownStats["googJitterBufferMs"] = Number(value);
              break;
            case "googJitterReceived":
              var jitterReceived = Number(value);
              if (jitterReceived !== -1) {
                knownStats["jitter"] = jitterReceived;
              }
              break;
            case "bytesReceived":
            case "bytesSent":
            case "packetsReceived":
            case "packetsSent":
            case "timestamp":
            case "audioInputLevel":
            case "audioOutputLevel":
              knownStats[name] = Number(value);
              break;
            case "packetsLost":
              var packetsLost = Number(value);
              if (packetsLost !== -1) {
                knownStats[name] = packetsLost;
              }
              break;
            default:
              unknownStats[name] = value;
          }
        });
        knownStats.timestamp = timestamp;
        return packageStats(knownStats, unknownStats);
      }
      function mozWithStats(reports, callback) {
        var knownStats = [];
        var unknownStats = [];
        reports.forEach(function(report) {
          var processedReport = null;
          switch (report.type) {
            case "inboundrtp":
              processedReport = processInbound(report);
              break;
            case "outboundrtp":
              if (report.isRemote === false) {
                processedReport = processOutbound(report);
              }
              break;
            default:
              unknownStats.push(report);
          }
          if (processedReport) {
            knownStats.push(processedReport);
          }
        });
        if (knownStats.length === 0 || (knownStats = filterKnownStats(knownStats)).length === 0) {
          return callback(null, {});
        }
        var mergedStats = knownStats.reduceRight(function(mergedStat, knownStat) {
          for (var name in knownStat) {
            mergedStat[name] = knownStat[name];
          }
          return mergedStat;
        }, {});
        callback(null, mergedStats);
      }
      function processOutbound(report) {
        var knownStats = {};
        var unknownStats = {};
        for (var name in report) {
          var value = report[name];
          switch (name) {
            case "timestamp":
              knownStats.timestamp = value ? Number(value) : null;
            case "bytesSent":
            case "packetsSent":
              knownStats[name] = value;
              break;
            default:
              unknownStats[name] = value;
          }
        }
        return packageStats(knownStats, unknownStats);
      }
      function processInbound(report) {
        var knownStats = {};
        var unknownStats = {};
        for (var name in report) {
          var value = report[name];
          switch (name) {
            case "mozRtt":
              knownStats["rtt"] = value;
              break;
            case "timestamp":
              knownStats.timestamp = value ? Number(value) : null;
              break;
            case "jitter":
              knownStats[name] = value * 1e3;
              break;
            case "bytesReceived":
            case "packetsLost":
            case "packetsReceived":
              knownStats[name] = value;
              break;
            default:
              unknownStats[name] = value;
          }
        }
        return packageStats(knownStats, unknownStats);
      }
      function packageStats(knownStats, unknownStats) {
        var stats = null;
        if (!empty(knownStats)) {
          stats = stats || {};
          stats.known = knownStats;
        }
        if (!empty(unknownStats)) {
          stats = stats || {};
          stats.unknown = unknownStats;
        }
        return stats;
      }
      function filterKnownStats(stats) {
        var knownStats = [];
        for (var i2 = 0; i2 < stats.length; i2++) {
          var stat = stats[i2];
          if (stat.known) {
            knownStats.push(stat.known);
          }
        }
        return knownStats;
      }
      function empty(obj) {
        if (!obj) {
          return true;
        }
        for (var key in obj) {
          return false;
        }
        return true;
      }
      function chainCallback(func, callback) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          args.push(callback);
          return func.apply(null, args);
        };
      }
      module2.exports = getStatistics;
    }, {}], 16: [function(require2, module2, exports2) {
      function Sound(options) {
        if (!(this instanceof Sound)) {
          return new Sound(options);
        }
        this.id = Sound.nextId++;
        this.maxDuration = options.maxDuration;
        Sound.items[this.id] = this;
        this.create(!!options.loop);
        return this;
      }
      var audioBackend = {
        create: function(shouldLoop) {
          this.audio = document.createElement("audio");
          this.audio.loop = shouldLoop;
          this.playing = false;
          var self = this;
          this.audio.addEventListener("ended", function() {
            self.playing = false;
          });
        },
        buffer: function() {
        },
        play: function() {
          if (this.playing) {
            return;
          }
          var audio = this.audio;
          this.rewind();
          var self = this;
          var maxDuration = this.maxDuration;
          if (maxDuration && maxDuration < audio.duration * 1e3) {
            setTimeout(function() {
              audio.pause();
              self.playing = false;
            }, maxDuration);
          }
          this.playing = true;
          audio.play();
        },
        load: function(url) {
          this.audio.src = url;
        },
        stop: function() {
          this.playing = false;
          this.audio.pause();
          this.rewind();
        },
        destroy: function() {
          this.audio.src = "";
          delete this.audio;
        },
        rewind: function() {
          this.audio.currentTime = 0;
          if (this.audio.currentTime) {
            this.audio.load();
          }
        }
      };
      var dummyBackend = {
        create: function() {
        },
        buffer: function(bytes) {
        },
        play: function() {
        },
        load: function(url) {
        },
        stop: function() {
        },
        destroy: function() {
        }
      };
      if (typeof window === "undefined") {
        for (var key in dummyBackend) {
          Sound.prototype[key] = dummyBackend[key];
        }
      } else {
        Sound.prototype = audioBackend;
      }
      Sound.nextId = 0;
      Sound.debug = false;
      Sound.tasks = [];
      Sound.items = {};
      exports2.Sound = Sound;
    }, {}], 17: [function(require2, module2, exports2) {
      function not(expr) {
        return !expr;
      }
      function bind(ctx, fn) {
        return function() {
          var args = Array.prototype.slice(arguments);
          fn.apply(ctx, args);
        };
      }
      function SoundCache() {
        if (not(this instanceof SoundCache)) {
          return new SoundCache();
        }
        this.cache = {};
      }
      SoundCache.prototype.add = function(name, sounds, envelope) {
        envelope = envelope || {};
        if (not(envelope instanceof Object)) {
          throw new TypeError("Bad envelope type; expected Object");
        }
        if (not(sounds instanceof Array)) {
          sounds = [sounds];
        }
        this.cache[name] = {
          starttime: null,
          sounds,
          envelope
        };
      };
      SoundCache.prototype.play = function(name, position, loop) {
        position = position || 0;
        loop = loop || 1;
        if (not(name in this.cache)) {
          return;
        }
        var voice = this.cache[name];
        for (var i2 = 0; i2 < voice.sounds.length; i2++) {
          voice.sounds[i2].play(position, loop);
        }
        voice.starttime = new Date().getTime();
      };
      SoundCache.prototype.stop = function(name) {
        if (not(name in this.cache)) {
          return;
        }
        var voice = this.cache[name];
        var release = voice.envelope.release || 0;
        var pauseFn = function() {
          for (var i2 = 0; i2 < voice.sounds.length; i2++) {
            voice.sounds[i2].stop();
          }
        };
        var now = new Date().getTime();
        var hold = Math.max(0, release - (now - voice.starttime));
        var _ = release == 0 ? pauseFn() : setTimeout(pauseFn, hold);
      };
      SoundCache.prototype.envelope = function(name, update) {
        if (not(name in this.cache)) {
          return;
        }
        var voice = this.cache[name];
        for (var prop in update) {
          voice.envelope[prop] = update[prop];
        }
      };
      SoundCache.prototype.playseq = function() {
        var timer = null;
        var queue = [];
        var playFn = function() {
          var tuple = queue.shift();
          if (!tuple) {
            timer = null;
            return;
          }
          var name = tuple[0], duration = tuple[1] || 0, pause = tuple[2] || 0;
          if (name in this.cache) {
            this.play(name);
          }
          timer = setTimeout(bind(this, playFn), duration + pause);
        };
        return function(sequence) {
          for (var i2 = 0; i2 < sequence.length; i2++) {
            queue.push(sequence[i2]);
          }
          if (timer == null) {
            timer = setTimeout(bind(this, playFn), 0);
          }
        };
      }();
      exports2.SoundCache = SoundCache;
    }, {}], 18: [function(require2, module2, exports2) {
      "use strict";
      var inherits = require2("util").inherits;
      function StateMachine(states, initialState) {
        if (!(this instanceof StateMachine)) {
          return new StateMachine(states, initialState);
        }
        var currentState = initialState;
        Object.defineProperties(this, {
          _currentState: {
            get: function() {
              return currentState;
            },
            set: function(_currentState) {
              currentState = _currentState;
            }
          },
          currentState: {
            enumerable: true,
            get: function() {
              return currentState;
            }
          },
          states: {
            enumerable: true,
            value: states
          },
          transitions: {
            enumerable: true,
            value: []
          }
        });
        Object.freeze(this);
      }
      StateMachine.prototype.transition = function transition(to) {
        var from = this.currentState;
        var valid = this.states[from];
        var transition2 = valid && valid.indexOf(to) !== -1 ? new StateTransition(from, to) : new InvalidStateTransition(from, to);
        this.transitions.push(transition2);
        this._currentState = to;
        if (transition2 instanceof InvalidStateTransition) {
          throw transition2;
        }
        return this;
      };
      function StateTransition(from, to) {
        Object.defineProperties(this, {
          from: {
            enumerable: true,
            value: from
          },
          to: {
            enumerable: true,
            value: to
          }
        });
      }
      function InvalidStateTransition(from, to) {
        if (!(this instanceof InvalidStateTransition)) {
          return new InvalidStateTransition(from, to);
        }
        Error.call(this);
        StateTransition.call(this, from, to);
        var errorMessage = "Invalid transition from " + (typeof from === "string" ? '"' + from + '"' : "null") + ' to "' + to + '"';
        Object.defineProperties(this, {
          message: {
            enumerable: true,
            value: errorMessage
          }
        });
        Object.freeze(this);
      }
      inherits(InvalidStateTransition, Error);
      module2.exports = StateMachine;
    }, { "util": 37 }], 19: [function(require2, module2, exports2) {
      var EventEmitter = require2("events").EventEmitter;
      function getPStreamVersion() {
        return "1.3";
      }
      function getSDKHash() {
        return "a95f379";
      }
      function getReleaseVersion() {
        return "1.3.16";
      }
      function getSoundVersion() {
        return "1.0.0";
      }
      function _Exception(message) {
        if (!(this instanceof _Exception))
          return new _Exception(message);
        this.message = message;
      }
      _Exception.prototype.toString = function() {
        return "Twilio.Exception: " + this.message;
      };
      function memoize(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments, 0);
          fn.memo = fn.memo || {};
          return fn.memo[args] ? fn.memo[args] : fn.memo[args] = fn.apply(null, args);
        };
      }
      function decodePayload(encoded_payload) {
        var remainder = encoded_payload.length % 4;
        if (remainder > 0) {
          var padlen = 4 - remainder;
          encoded_payload += new Array(padlen + 1).join("=");
        }
        encoded_payload = encoded_payload.replace(/-/g, "+").replace(/_/g, "/");
        var decoded_payload = _atob(encoded_payload);
        return JSON.parse(decoded_payload);
      }
      var memoizedDecodePayload = memoize(decodePayload);
      function decode(token) {
        var segs = token.split(".");
        if (segs.length != 3) {
          throw new _Exception("Wrong number of segments");
        }
        var encoded_payload = segs[1];
        var payload = memoizedDecodePayload(encoded_payload);
        return payload;
      }
      function makedict(params) {
        if (params == "")
          return {};
        if (params.indexOf("&") == -1 && params.indexOf("=") == -1)
          return params;
        var pairs = params.split("&");
        var result = {};
        for (var i2 = 0; i2 < pairs.length; i2++) {
          var pair = pairs[i2].split("=");
          result[decodeURIComponent(pair[0])] = makedict(decodeURIComponent(pair[1]));
        }
        return result;
      }
      function makescope(uri) {
        var parts = uri.match(/^scope:(\w+):(\w+)\??(.*)$/);
        if (!(parts && parts.length == 4)) {
          throw new _Exception("Bad scope URI");
        }
        return {
          service: parts[1],
          privilege: parts[2],
          params: makedict(parts[3])
        };
      }
      function urlencode(params_dict, doseq) {
        var parts = [];
        doseq = doseq || false;
        for (var key in params_dict) {
          if (doseq && params_dict[key] instanceof Array) {
            for (var index in params_dict[key]) {
              var value = params_dict[key][index];
              parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }
          } else {
            var value = params_dict[key];
            parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
          }
        }
        return parts.join("&");
      }
      function objectize(token) {
        var jwt = decode(token);
        var scopes = jwt.scope.length === 0 ? [] : jwt.scope.split(" ");
        var newscopes = {};
        for (var i2 = 0; i2 < scopes.length; i2++) {
          var scope = makescope(scopes[i2]);
          newscopes[scope.service + ":" + scope.privilege] = scope;
        }
        jwt.scope = newscopes;
        return jwt;
      }
      var memoizedObjectize = memoize(objectize);
      function _btoa(message) {
        try {
          return btoa(message);
        } catch (e) {
          return new Buffer(message).toString("base64");
        }
      }
      function _atob(encoded) {
        try {
          return atob(encoded);
        } catch (e) {
          try {
            return new Buffer(encoded, "base64").toString("ascii");
          } catch (e2) {
            return base64.decode(encoded);
          }
        }
      }
      function dummyToken(payload) {
        var token_defaults = {
          "iss": "AC1111111111111111111111111111111",
          "exp": 14e8
        };
        for (var k in token_defaults) {
          payload[k] = payload[k] || token_defaults[k];
        }
        var encoded_payload = _btoa(JSON.stringify(payload));
        encoded_payload = encoded_payload.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        return ["*", encoded_payload, "*"].join(".");
      }
      function encodescope(service, privilege, params) {
        var capability = ["scope", service, privilege].join(":");
        var empty = true;
        for (var _ in params) {
          empty = false;
          break;
        }
        return empty ? capability : capability + "?" + buildquery(params);
      }
      function buildquery(params) {
        var pairs = [];
        for (var name in params) {
          var value = typeof params[name] == "object" ? buildquery(params[name]) : params[name];
          pairs.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
        }
        return pairs.join("&");
      }
      var bind = function(fn, ctx) {
        var applied = Array.prototype.slice.call(arguments, 2);
        return function() {
          var extra = Array.prototype.slice.call(arguments);
          return fn.apply(ctx, applied.concat(extra));
        };
      };
      var Set2 = function() {
        function Set3() {
          this.set = {};
        }
        Set3.prototype.clear = function() {
          this.set = {};
        };
        Set3.prototype.put = function(elem) {
          return this.set[elem] = Set3.DUMMY;
        };
        Set3.prototype.del = function(elem) {
          return delete this.set[elem];
        };
        Set3.prototype.map = function(fn, this_) {
          var results = [];
          for (var item in this.set) {
            results.push(fn.call(this_, item));
          }
          return results;
        };
        Set3.DUMMY = {};
        return Set3;
      }();
      var getSystemInfo = function() {
        var rtc = require2("./rtc"), version = getPStreamVersion(), hash = getSDKHash(), nav = typeof navigator != "undefined" ? navigator : {};
        var info = {
          p: "browser",
          v: version,
          h: hash,
          browser: {
            userAgent: nav.userAgent || "unknown",
            platform: nav.platform || "unknown"
          },
          plugin: "rtc"
        };
        return info;
      };
      function trim(str) {
        if (typeof str != "string")
          return "";
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitObjects(json, validate) {
        var trimmed = trim(json);
        return trimmed.length == 0 ? [] : trimmed.split("\n");
      }
      function generateConnectionUUID() {
        return "TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
          return v.toString(16);
        });
      }
      var TWILIO_ROOT = "";
      function getTwilioRoot() {
        return TWILIO_ROOT;
      }
      function setTwilioRoot(twilioRoot) {
        TWILIO_ROOT = twilioRoot;
      }
      function monitorEventEmitter(name, object) {
        object.setMaxListeners(0);
        var MAX_LISTENERS = 10;
        function monitor(event) {
          var n = EventEmitter.listenerCount(object, event);
          var warning = "The number of " + event + " listeners on " + name + " exceeds the recommended number of " + MAX_LISTENERS + ". While twilio.js will continue to function normally, this may be indicative of an application error. Note that " + event + " listeners exist for the lifetime of the " + name + ".";
          if (n >= MAX_LISTENERS) {
            if (typeof console !== "undefined") {
              if (console.warn) {
                console.warn(warning);
              } else if (console.log) {
                console.log(warning);
              }
            }
            object.removeListener("newListener", monitor);
          }
        }
        object.on("newListener", monitor);
      }
      function deepEqual(a, b) {
        if (a === b) {
          return true;
        } else if (typeof a !== typeof b) {
          return false;
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime();
        } else if (typeof a !== "object" && typeof b !== "object") {
          return a == b;
        } else {
          return objectDeepEqual(a, b);
        }
      }
      var objectKeys = typeof Object.keys === "function" ? Object.keys : function(obj) {
        var keys = [];
        for (var key in obj) {
          keys.push(key);
        }
        return keys;
      };
      function isUndefinedOrNull(a) {
        return a === void 0 || a === null;
      }
      function objectDeepEqual(a, b) {
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
          return false;
        } else if (a.prototype !== b.prototype) {
          return false;
        } else {
          try {
            var ka = objectKeys(a);
            var kb = objectKeys(b);
          } catch (e) {
            return false;
          }
          if (ka.length !== kb.length) {
            return false;
          }
          ka.sort();
          kb.sort();
          for (var i2 = ka.length - 1; i2 >= 0; i2--) {
            var k = ka[i2];
            if (!deepEqual(a[k], b[k])) {
              return false;
            }
          }
          return true;
        }
      }
      exports2.getPStreamVersion = getPStreamVersion;
      exports2.getReleaseVersion = getReleaseVersion;
      exports2.getSoundVersion = getSoundVersion;
      exports2.encodescope = encodescope;
      exports2.dummyToken = dummyToken;
      exports2.Exception = _Exception;
      exports2.decode = decode;
      exports2.btoa = _btoa;
      exports2.atob = _atob;
      exports2.objectize = memoizedObjectize;
      exports2.urlencode = urlencode;
      exports2.Set = Set2;
      exports2.bind = bind;
      exports2.getSystemInfo = getSystemInfo;
      exports2.splitObjects = splitObjects;
      exports2.generateConnectionUUID = generateConnectionUUID;
      exports2.getTwilioRoot = getTwilioRoot;
      exports2.setTwilioRoot = setTwilioRoot;
      exports2.monitorEventEmitter = monitorEventEmitter;
      exports2.deepEqual = deepEqual;
    }, { "./rtc": 11, "events": 21 }], 20: [function(require2, module2, exports2) {
      var Heartbeat = require2("./heartbeat").Heartbeat;
      var log = require2("./log");
      var WebSocket = require2("ws");
      function WSTransport(options) {
        var self = this instanceof WSTransport ? this : new WSTransport(options);
        self.sock = null;
        var noop = function() {
        };
        self.onopen = noop;
        self.onclose = noop;
        self.onmessage = noop;
        self.onerror = noop;
        var defaults = {
          logPrefix: "[WSTransport]",
          chunderw: "chunderw-vpc-gll.twilio.com",
          reconnect: true,
          debug: false,
          secureSignaling: true
        };
        options = options || {};
        for (var prop in defaults) {
          if (prop in options)
            continue;
          options[prop] = defaults[prop];
        }
        self.options = options;
        log.mixinLog(self, self.options["logPrefix"]);
        self.log.enabled = self.options["debug"];
        self.defaultReconnect = self.options["reconnect"];
        var scheme = self.options["secureSignaling"] ? "wss://" : "ws://";
        self.uri = scheme + self.options["host"] + "/signal";
        return self;
      }
      WSTransport.prototype.msgQueue = [];
      WSTransport.prototype.open = function(attempted) {
        this.log("Opening socket");
        if (this.sock && this.sock.readyState < 2) {
          this.log("Socket already open.");
          return;
        }
        this.options["reconnect"] = this.defaultReconnect;
        if (this.heartbeat) {
          this.heartbeat.onsleep = function() {
          };
        }
        this.heartbeat = new Heartbeat({ "interval": 15 });
        this.sock = this._connect(attempted);
      };
      WSTransport.prototype.send = function(msg) {
        if (this.sock) {
          if (this.sock.readyState == 0) {
            this.msgQueue.push(msg);
            return;
          }
          try {
            this.sock.send(msg);
          } catch (error) {
            this.log("Error while sending. Closing socket: " + error.message);
            this.sock.close();
          }
        }
      };
      WSTransport.prototype.close = function() {
        this.log("Closing socket");
        this.options["reconnect"] = false;
        if (this.sock) {
          this.sock.close();
          this.sock = null;
        }
        this.heartbeat.onsleep = function() {
        };
      };
      WSTransport.prototype._cleanupSocket = function(socket) {
        if (socket) {
          this.log("Cleaning up socket");
          var noop = function() {
          };
          socket.onopen = function() {
            socket.close();
          };
          socket.onmessage = noop;
          socket.onerror = noop;
          socket.onclose = noop;
          if (socket.readyState < 2) {
            socket.close();
          }
        }
      };
      WSTransport.prototype._connect = function(attempted) {
        var attempt = ++attempted || 1;
        this.log("attempting to connect");
        var sock = null;
        try {
          sock = new WebSocket(this.uri);
        } catch (e) {
          this.onerror({ code: 31e3, message: e.message || "Could not connect to " + this.uri });
          this.close();
          return;
        }
        var self = this;
        var oldSocket = this.sock;
        var getTime = function() {
          return new Date().getTime();
        };
        var timeOpened = null;
        var connectTimeout = setTimeout(function() {
          self.log("connection attempt timed out");
          sock.onclose = function() {
          };
          sock.close();
          self.onclose();
          self._tryReconnect(attempt);
        }, 5e3);
        sock.onopen = function() {
          clearTimeout(connectTimeout);
          self._cleanupSocket(oldSocket);
          timeOpened = getTime();
          self.log("Socket opened");
          self.heartbeat.onsleep = function() {
            self.log("Heartbeat timed out. closing socket");
            self.sock.onclose = function() {
            };
            self.sock.close();
            self.onclose();
            self._tryReconnect(attempt);
          };
          self.heartbeat.beat();
          self.onopen();
          for (var i2 = 0; i2 < self.msgQueue.length; i2++) {
            self.sock.send(self.msgQueue[i2]);
          }
          self.msgQueue = [];
        };
        sock.onclose = function() {
          clearTimeout(connectTimeout);
          self._cleanupSocket(oldSocket);
          self.heartbeat.onsleep = function() {
          };
          if (timeOpened) {
            var socketDuration = (getTime() - timeOpened) / 1e3;
            if (socketDuration > 10) {
              attempt = 1;
            }
          }
          self.log("Socket closed");
          self.onclose();
          self._tryReconnect(attempt);
        };
        sock.onerror = function(e) {
          self.log("Socket received error: " + e.message);
          self.onerror({ code: 31e3, message: e.message || "WSTransport socket error" });
        };
        sock.onmessage = function(message) {
          self.heartbeat.beat();
          if (message.data == "\n") {
            self.send("\n");
            return;
          }
          self.onmessage(message);
        };
        return sock;
      };
      WSTransport.prototype._tryReconnect = function(attempted) {
        attempted = attempted || 0;
        if (this.options["reconnect"]) {
          this.log("Attempting to reconnect.");
          var self = this;
          var backoff = 0;
          if (attempted < 5) {
            var minBackoff = 30;
            var backoffRange = Math.pow(2, attempted) * 50;
            backoff = minBackoff + Math.round(Math.random() * backoffRange);
          } else {
            backoff = 3e3;
          }
          setTimeout(function() {
            self.open(attempted);
          }, backoff);
        }
      };
      exports2.WSTransport = WSTransport;
    }, { "./heartbeat": 6, "./log": 7, "ws": 38 }], 21: [function(require2, module2, exports2) {
      function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || void 0;
      }
      module2.exports = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
          throw TypeError("n must be a positive number");
        this._maxListeners = n;
        return this;
      };
      EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i2, listeners;
        if (!this._events)
          this._events = {};
        if (type === "error") {
          if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
            er = arguments[1];
            if (er instanceof Error) {
              throw er;
            } else {
              var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
              err.context = er;
              throw err;
            }
          }
        }
        handler = this._events[type];
        if (isUndefined(handler))
          return false;
        if (isFunction(handler)) {
          switch (arguments.length) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              args = Array.prototype.slice.call(arguments, 1);
              handler.apply(this, args);
          }
        } else if (isObject(handler)) {
          args = Array.prototype.slice.call(arguments, 1);
          listeners = handler.slice();
          len = listeners.length;
          for (i2 = 0; i2 < len; i2++)
            listeners[i2].apply(this, args);
        }
        return true;
      };
      EventEmitter.prototype.addListener = function(type, listener) {
        var m;
        if (!isFunction(listener))
          throw TypeError("listener must be a function");
        if (!this._events)
          this._events = {};
        if (this._events.newListener)
          this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type])
          this._events[type] = listener;
        else if (isObject(this._events[type]))
          this._events[type].push(listener);
        else
          this._events[type] = [this._events[type], listener];
        if (isObject(this._events[type]) && !this._events[type].warned) {
          if (!isUndefined(this._maxListeners)) {
            m = this._maxListeners;
          } else {
            m = EventEmitter.defaultMaxListeners;
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
            if (typeof console.trace === "function") {
              console.trace();
            }
          }
        }
        return this;
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener))
          throw TypeError("listener must be a function");
        var fired = false;
        function g() {
          this.removeListener(type, g);
          if (!fired) {
            fired = true;
            listener.apply(this, arguments);
          }
        }
        g.listener = listener;
        this.on(type, g);
        return this;
      };
      EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i2;
        if (!isFunction(listener))
          throw TypeError("listener must be a function");
        if (!this._events || !this._events[type])
          return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || isFunction(list.listener) && list.listener === listener) {
          delete this._events[type];
          if (this._events.removeListener)
            this.emit("removeListener", type, listener);
        } else if (isObject(list)) {
          for (i2 = length; i2-- > 0; ) {
            if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
              position = i2;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list.length = 0;
            delete this._events[type];
          } else {
            list.splice(position, 1);
          }
          if (this._events.removeListener)
            this.emit("removeListener", type, listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;
        if (!this._events)
          return this;
        if (!this._events.removeListener) {
          if (arguments.length === 0)
            this._events = {};
          else if (this._events[type])
            delete this._events[type];
          return this;
        }
        if (arguments.length === 0) {
          for (key in this._events) {
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = {};
          return this;
        }
        listeners = this._events[type];
        if (isFunction(listeners)) {
          this.removeListener(type, listeners);
        } else if (listeners) {
          while (listeners.length)
            this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];
        return this;
      };
      EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
          ret = [];
        else if (isFunction(this._events[type]))
          ret = [this._events[type]];
        else
          ret = this._events[type].slice();
        return ret;
      };
      EventEmitter.prototype.listenerCount = function(type) {
        if (this._events) {
          var evlistener = this._events[type];
          if (isFunction(evlistener))
            return 1;
          else if (evlistener)
            return evlistener.length;
        }
        return 0;
      };
      EventEmitter.listenerCount = function(emitter, type) {
        return emitter.listenerCount(type);
      };
      function isFunction(arg) {
        return typeof arg === "function";
      }
      function isNumber(arg) {
        return typeof arg === "number";
      }
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      function isUndefined(arg) {
        return arg === void 0;
      }
    }, {}], 22: [function(require2, module2, exports2) {
      "use strict";
      module2.exports.RTCIceCandidate = require2("./rtcicecandidate");
      module2.exports.RTCPeerConnection = require2("./rtcpeerconnection");
      module2.exports.RTCSessionDescription = require2("./rtcsessiondescription");
    }, { "./rtcicecandidate": 25, "./rtcpeerconnection": 26, "./rtcsessiondescription": 28 }], 23: [function(require2, module2, exports2) {
      "use strict";
      function MediaSection(address, _candidates, capabilities, direction, kind, mid, port, rtcpMux, streamId, track) {
        if (!(this instanceof MediaSection)) {
          return new MediaSection(address, _candidates, capabilities, direction, kind, mid, port, rtcpMux, streamId, track);
        }
        var rejected = false;
        address = address || "0.0.0.0";
        port = typeof port === "number" ? port : 9;
        rtcpMux = typeof rtcpMux === "boolean" ? rtcpMux : true;
        streamId = streamId || null;
        track = track || null;
        Object.defineProperties(this, {
          _address: {
            get: function() {
              return address;
            },
            set: function(_address) {
              address = _address;
            }
          },
          _candidates: {
            value: []
          },
          _port: {
            get: function() {
              return port;
            },
            set: function(_port) {
              port = _port;
            }
          },
          _rejected: {
            get: function() {
              return rejected;
            },
            set: function(_rejected) {
              rejected = _rejected;
            }
          },
          _streamId: {
            get: function() {
              return streamId;
            },
            set: function(_streamId) {
              streamId = _streamId;
            }
          },
          _track: {
            get: function() {
              return track;
            },
            set: function(_track) {
              track = _track;
            }
          },
          _triples: {
            value: /* @__PURE__ */ new Set()
          },
          candidates: {
            enumerable: true,
            get: function() {
              return this._candidates.slice();
            }
          },
          capabilities: {
            enumerable: true,
            value: capabilities
          },
          defaultCandidate: {
            enumerable: true,
            get: function() {
              return this._candidates.length ? this._candidates[0] : null;
            }
          },
          direction: {
            enumerable: true,
            value: direction
          },
          kind: {
            enumerable: true,
            value: kind
          },
          port: {
            enumerable: true,
            get: function() {
              return port;
            }
          },
          rtcpMux: {
            enumerable: true,
            value: rtcpMux
          },
          streamId: {
            enumerable: true,
            get: function() {
              return streamId;
            }
          },
          track: {
            enumerable: true,
            get: function() {
              return track;
            }
          }
        });
        if (_candidates) {
          _candidates.forEach(this.addCandidate, this);
        }
      }
      MediaSection.prototype.addCandidate = function addCandidate(candidate) {
        var triple = [
          candidate.ip,
          candidate.port,
          candidate.protocol
        ].join(" ");
        if (!this._triples.has(triple)) {
          this._triples.add(triple);
          this._candidates.push(candidate);
          return true;
        }
        return false;
      };
      MediaSection.prototype.copy = function copy(address, candidates, capabilities, direction, port, streamId, track) {
        return new MediaSection(this.address, candidates, capabilities || this.capabilities, direction || this.direction, this.kind, this.mid, port, this.rtcpMux, streamId, track);
      };
      MediaSection.prototype.copyAndReject = function copyAndReject() {
        var mediaSection = new MediaSection(null, this.candidates, this.capabilities, this.direction, this.kind, this.mid, null, this.rtcpMux);
        return mediaSection.reject();
      };
      MediaSection.prototype.reject = function reject() {
        this.setPort(0);
        return this;
      };
      MediaSection.prototype.setAddress = function setAddress(address) {
        this._address = address;
        return this;
      };
      MediaSection.prototype.setPort = function setPort(port) {
        this._port = port;
        return this;
      };
      module2.exports = MediaSection;
    }, {}], 24: [function(require2, module2, exports2) {
      "use strict";
      function MediaStreamEvent(type, init) {
        if (!(this instanceof MediaStreamEvent)) {
          return new MediaStreamEvent(type, init);
        }
        Event.call(this, type, init);
        Object.defineProperties(this, {
          stream: {
            enumerable: true,
            value: init.stream
          }
        });
      }
      module2.exports = MediaStreamEvent;
    }, {}], 25: [function(require2, module2, exports2) {
      "use strict";
      function RTCIceCandidate2(candidate) {
        if (!(this instanceof RTCIceCandidate2)) {
          return new RTCIceCandidate2(candidate);
        }
        Object.defineProperties(this, {
          candidate: {
            enumerable: true,
            value: candidate.candidate
          },
          sdpMLineIndex: {
            enumerable: true,
            value: candidate.sdpMLineIndex
          }
        });
      }
      module2.exports = RTCIceCandidate2;
    }, {}], 26: [function(require2, module2, exports2) {
      "use strict";
      var MediaSection = require2("./mediasection");
      var MediaStreamEvent = require2("./mediastreamevent");
      var RTCIceCandidate2 = require2("./rtcicecandidate");
      var RTCPeerConnectionIceEvent = require2("./rtcpeerconnectioniceevent");
      var RTCSessionDescription2 = require2("./rtcsessiondescription");
      var sdpTransform = require2("sdp-transform");
      var sdpUtils = require2("./sdp-utils");
      function RTCPeerConnection(configuration) {
        if (!(this instanceof RTCPeerConnection)) {
          return new RTCPeerConnection(configuration);
        }
        var gatherOptions = makeGatherOptions(configuration);
        var iceGatherer = new RTCIceGatherer(gatherOptions);
        var iceGatheringCompleted = false;
        iceGatherer.onlocalcandidate = this._onlocalcandidate.bind(this);
        var onicecandidate = null;
        var onicecandidateWasSet = false;
        var iceCandidatesAdded = 0;
        var iceTransport = new RTCIceTransport();
        var oniceconnectionstatechange = null;
        iceTransport.onicestatechange = this._onicestatechange.bind(this);
        var dtlsTransport = new RTCDtlsTransport(iceTransport);
        dtlsTransport.ondtlsstatechange = this._ondtlsstatechange.bind(this);
        var signalingState = "stable";
        var onsignalingstatechange = null;
        var localDescription = null;
        var remoteDescription = null;
        var onaddstream = null;
        Object.defineProperties(this, {
          _dtlsTransport: {
            value: dtlsTransport
          },
          _dtmfSenders: {
            value: /* @__PURE__ */ new Map()
          },
          _gatherOptions: {
            value: gatherOptions
          },
          _iceCandidatesAdded: {
            get: function() {
              return iceCandidatesAdded;
            },
            set: function(_iceCandidatesAdded) {
              iceCandidatesAdded = _iceCandidatesAdded;
            }
          },
          _iceGatherer: {
            value: iceGatherer
          },
          _iceGatheringCompleted: {
            get: function() {
              return iceGatheringCompleted;
            },
            set: function(_iceGatheringCompleted) {
              iceGatheringCompleted = _iceGatheringCompleted;
            }
          },
          _iceTransport: {
            value: iceTransport
          },
          _localCandidates: {
            value: /* @__PURE__ */ new Set()
          },
          _localDescription: {
            get: function() {
              return localDescription;
            },
            set: function(_localDescription) {
              localDescription = _localDescription;
            }
          },
          _localStreams: {
            value: []
          },
          _midCounters: {
            value: {
              audio: 0,
              video: 0
            }
          },
          _remoteCandidates: {
            value: /* @__PURE__ */ new Set()
          },
          _remoteDescription: {
            get: function() {
              return remoteDescription;
            },
            set: function(_remoteDescription) {
              remoteDescription = _remoteDescription;
            }
          },
          _remoteStreams: {
            value: []
          },
          _rtpReceivers: {
            value: /* @__PURE__ */ new Map()
          },
          _rtpSenders: {
            value: /* @__PURE__ */ new Map()
          },
          _signalingState: {
            get: function() {
              return signalingState;
            },
            set: function(_signalingState) {
              signalingState = _signalingState;
              if (this.onsignalingstatechange) {
                this.onsignalingstatechange();
              }
            }
          },
          _streamIds: {
            value: /* @__PURE__ */ new Map()
          },
          iceConnectionState: {
            enumerable: true,
            get: function() {
              return iceTransport.state;
            }
          },
          iceGatheringState: {
            enumerable: true,
            get: function() {
              return iceGatheringCompleted ? "gathering" : "complete";
            }
          },
          localDescription: {
            enumerable: true,
            get: function() {
              return localDescription;
            }
          },
          onaddstream: {
            enumerable: true,
            get: function() {
              return onaddstream;
            },
            set: function(_onaddstream) {
              onaddstream = _onaddstream;
            }
          },
          onicecandidate: {
            enumerable: true,
            get: function() {
              return onicecandidate;
            },
            set: function(_onicecandidate) {
              onicecandidate = _onicecandidate;
              if (!onicecandidateWasSet) {
                try {
                  iceGatherer.getLocalCandidates().forEach(iceGatherer.onlocalcandidate);
                } catch (error) {
                }
              }
              onicecandidateWasSet = true;
            }
          },
          oniceconnectionstatechange: {
            enumerable: true,
            get: function() {
              return oniceconnectionstatechange;
            },
            set: function(_oniceconnectionstatechange) {
              oniceconnectionstatechange = _oniceconnectionstatechange;
            }
          },
          onsignalingstatechange: {
            enumerable: true,
            get: function() {
              return onsignalingstatechange;
            },
            set: function(_onsignalingstatechange) {
              onsignalingstatechange = _onsignalingstatechange;
            }
          },
          remoteDescription: {
            enumerable: true,
            get: function() {
              return remoteDescription;
            }
          },
          signalingState: {
            enumerable: true,
            get: function() {
              return signalingState;
            }
          }
        });
      }
      RTCPeerConnection.prototype._makeMid = function _makeMid(kind) {
        return kind + ++this._midCounters[kind];
      };
      RTCPeerConnection.prototype._ondtlsstatechange = function _ondtlsstatechange(event) {
      };
      RTCPeerConnection.prototype._onicestatechange = function _onicestatechange(event) {
        if (this.oniceconnectionstatechange) {
          this.oniceconnectionstatechange(event);
        }
      };
      RTCPeerConnection.prototype._onlocalcandidate = function _onlocalcandidate(event) {
        if (isEmptyObject(event.candidate)) {
          this._iceGatheringCompleted = true;
        }
        this._localCandidates.add(event.candidate);
        if (this.onicecandidate) {
          var webrtcCandidate = makeWebRTCCandidate(event.candidate);
          this.onicecandidate(makeOnIceCandidateEvent(webrtcCandidate));
        }
      };
      RTCPeerConnection.prototype._sendRtp = function _sendRtp(mediaSection) {
        var kind = mediaSection.kind;
        this._rtpSenders.forEach(function(rtpSender) {
          if (rtpSender.track.kind !== kind) {
            return;
          }
          rtpSender.send(mediaSection.capabilities);
        }, this);
        return this;
      };
      RTCPeerConnection.prototype._sendAndReceiveRtp = function _sendAndReceiveRtp(mediaSections) {
        mediaSections.forEach(function(mediaSection) {
          if (mediaSection.direction === "sendrecv" || mediaSection.direction === "sendonly") {
            this._sendRtp(mediaSection);
          }
          if (mediaSection.direction === "sendrecv" || mediaSection.direction === "recvonly") {
            this._receiveRtp(mediaSection);
          }
        }, this);
        return this;
      };
      RTCPeerConnection.prototype._receiveRtp = function _receiveRtp(mediaSection) {
        var kind = mediaSection.capabilities.type;
        var rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
        rtpReceiver.receive(mediaSection.capabilities);
        var track = rtpReceiver.track;
        this._rtpReceivers.set(track, rtpReceiver);
        var mediaStream = new MediaStream();
        mediaStream.addTrack(track);
        this._remoteStreams.push(mediaStream);
        if (this.onaddstream) {
          this.onaddstream(makeOnAddStreamEvent(mediaStream));
        }
        return this;
      };
      RTCPeerConnection.prototype._startDtlsTransport = function _startDtlsTransport(dtlsParameters) {
        this._dtlsTransport.start(dtlsParameters);
        return this;
      };
      RTCPeerConnection.prototype._startIceTransport = function _startIceTransport(iceParameters) {
        var role = this.signalingState === "have-local-offer" ? "controlling" : "controlled";
        this._iceTransport.start(this._iceGatherer, iceParameters, role);
        return this;
      };
      RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate(candidate, onSuccess, onFailure) {
        this._iceCandidatesAdded++;
        var ortcCandidate = makeORTCCandidate(candidate);
        var triple = [ortcCandidate.ip, ortcCandidate.port, ortcCandidate.transport].join(" ");
        if (!this._remoteCandidates.has(triple)) {
          this._remoteCandidates.add(triple);
          this._iceTransport.addRemoteCandidate(ortcCandidate);
        }
        if (onSuccess) {
          onSuccess();
        }
      };
      RTCPeerConnection.prototype.addStream = function addStream(mediaStream) {
        this._localStreams.push(mediaStream);
        mediaStream.getTracks().forEach(function(track) {
          var rtpSender = new RTCRtpSender(track, this._dtlsTransport);
          this._rtpSenders.set(track, rtpSender);
          this._streamIds.set(track, mediaStream.id);
        }, this);
      };
      RTCPeerConnection.prototype.close = function close() {
        this._signalingState = "closed";
        this._rtpReceivers.forEach(function(rtpReceiver) {
          rtpReceiver.stop();
        });
        this._dtlsTransport.stop();
        this._iceTransport.stop();
      };
      RTCPeerConnection.prototype.createAnswer = function createAnswer(onSuccess, onFailure) {
        if (this.signalingState !== "have-remote-offer") {
          return void onFailure(invalidSignalingState(this.signalingState));
        }
        var remote = sdpUtils.parseDescription(this.remoteDescription);
        var streams = this.getLocalStreams();
        var tracks = { audio: [], video: [] };
        streams.forEach(function(stream) {
          tracks.audio = tracks.audio.concat(stream.getAudioTracks());
          tracks.video = tracks.video.concat(stream.getVideoTracks());
        });
        var mediaSections = remote.mediaSections.map(function(remoteMediaSection) {
          var kind = remoteMediaSection.kind;
          var remoteDirection = remoteMediaSection.direction;
          var remoteCapabilities = remoteMediaSection.capabilities;
          var localCapabilities = RTCRtpSender.getCapabilities(kind);
          var sharedCodecs = intersectCodecs(remoteCapabilities.codecs, localCapabilities.codecs);
          var sharedCapabilities = { codecs: sharedCodecs };
          var capabilities = sharedCapabilities;
          var direction;
          var track;
          if (!sharedCodecs.length) {
            return remoteMediaSection.copyAndReject();
          }
          if (remoteDirection === "inactive" || remoteDirection === "recvonly" && !tracks[kind].length) {
            direction = "inactive";
          } else if (remoteDirection === "recvonly") {
            track = tracks[kind].shift();
            direction = "sendonly";
          } else if (remoteDirection === "sendrecv") {
            track = tracks[kind].shift();
            direction = track ? "sendrecv" : "recvonly";
          } else {
            direction = "recvonly";
          }
          var streamId = this._streamIds.get(track);
          var mediaSection = remoteMediaSection.copy(null, null, capabilities, direction, null, streamId, track);
          return mediaSection;
        }, this);
        mediaSections.forEach(function(mediaSection) {
          this._localCandidates.forEach(mediaSection.addCandidate, mediaSection);
        }, this);
        var sdp = sdpUtils.makeInitialSDPBlob();
        sdpUtils.addMediaSectionsToSDPBlob(sdp, mediaSections);
        sdpUtils.addIceParametersToSDPBlob(sdp, this._iceGatherer.getLocalParameters());
        sdpUtils.addDtlsParametersToSDPBlob(sdp, this._dtlsTransport.getLocalParameters());
        var description = new RTCSessionDescription2({
          sdp: sdpTransform.write(sdp),
          type: "answer"
        });
        onSuccess(description);
      };
      RTCPeerConnection.prototype.createDTMFSender = function createDTMFSender(track) {
        if (!this._dtmfSenders.has(track)) {
          var rtpSender = this._rtpSenders.get(track);
          var dtmfSender = new RTCDtmfSender(rtpSender);
          this._dtmfSenders.set(track, dtmfSender);
        }
        return this._dtmfSenders.get(track);
      };
      RTCPeerConnection.prototype.createOffer = function createOffer(onSuccess, onFailure, options) {
        var N = { audio: null, video: null };
        var M = { audio: 0, video: 0 };
        options = options || {};
        ["optional", "mandatory"].forEach(function(optionType) {
          if (!(optionType in options)) {
            return;
          }
          if ("OfferToReceiveAudio" in options[optionType]) {
            N.audio = Number(options[optionType].OfferToReceiveAudio);
          }
          if ("OfferToReceiveVideo" in options[optionType]) {
            N.video = Number(options[optionType].OfferToReceiveVideo);
          }
        });
        var mediaSections = [];
        var _N = { audio: N.audio, video: N.video };
        var streams = this.getLocalStreams();
        streams.forEach(function(stream) {
          var audioTracks = stream.getAudioTracks();
          var videoTracks = stream.getVideoTracks();
          M.audio += audioTracks.length;
          M.video += videoTracks.length;
          var tracks = audioTracks.concat(videoTracks);
          tracks.forEach(function(track) {
            var kind = track.kind;
            var capabilities = RTCRtpSender.getCapabilities(kind);
            var direction;
            var mid = this._makeMid(kind);
            if (_N.audio === null) {
              direction = "sendrecv";
            } else if (!_N[kind]) {
              direction = "sendonly";
            } else {
              _N[kind]--;
              direction = "sendrecv";
            }
            var mediaSection = new MediaSection(null, null, capabilities, direction, kind, mid, null, null, stream.id, track);
            mediaSections.push(mediaSection);
          }, this);
        }, this);
        ["audio", "video"].forEach(function(kind) {
          var k = Math.max(N[kind] - M[kind], 0);
          if (!k) {
            return;
          }
          var capabilities = RTCRtpSender.getCapabilities(kind);
          var direction = "recvonly";
          var mid;
          var mediaSection;
          while (k--) {
            mid = this._makeMid(kind);
            mediaSection = new MediaSection(null, null, capabilities, direction, kind, mid);
            mediaSections.push(mediaSection);
          }
        }, this);
        mediaSections.forEach(function(mediaSection) {
          this._localCandidates.forEach(mediaSection.addCandidate, mediaSection);
        }, this);
        var sdp = sdpUtils.makeInitialSDPBlob();
        sdpUtils.addMediaSectionsToSDPBlob(sdp, mediaSections);
        sdpUtils.addIceParametersToSDPBlob(sdp, this._iceGatherer.getLocalParameters());
        sdpUtils.addDtlsParametersToSDPBlob(sdp, this._dtlsTransport.getLocalParameters());
        var description = new RTCSessionDescription2({
          sdp: sdpTransform.write(sdp),
          type: "offer"
        });
        onSuccess(description);
      };
      RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
        return this._localStreams.slice();
      };
      RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
        return this._remoteStreams.slice();
      };
      RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription(description, onSuccess, onFailure) {
        var nextSignalingState;
        switch (this.signalingState) {
          case "stable":
            nextSignalingState = "have-local-offer";
            break;
          case "have-remote-offer":
          case "have-local=offer":
            nextSignalingState = "stable";
            break;
          default:
            return void onFailure(invalidSignalingState(this.signalingState));
        }
        var parsed = sdpUtils.parseDescription(description);
        if (this.signalingState === "have-remote-offer") {
          parsed.mediaSections.forEach(this._sendRtp, this);
          var remote = sdpUtils.parseDescription(this.remoteDescription);
          var remoteSsrc = remote.mediaSections[0].capabilities.encodings[0].ssrc;
          parsed.mediaSections.forEach(function(mediaSection) {
            mediaSection.capabilities.encodings.forEach(function(encoding) {
              encoding.ssrc = remoteSsrc;
            });
            mediaSection.capabilities.rtcp.ssrc = remoteSsrc;
          });
          parsed.mediaSections.forEach(this._receiveRtp, this);
        }
        this._localDescription = description;
        this._signalingState = nextSignalingState;
        onSuccess();
      };
      RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(description, onSuccess, onFailure) {
        var nextSignalingState;
        console.info(this.signalingState, this.signalingState === "have-local-offer");
        switch (this.signalingState) {
          case "stable":
            nextSignalingState = "have-remote-offer";
            break;
          case "have-local-offer":
            nextSignalingState = "stable";
            break;
          default:
            console.info("WUT", this.signalingState);
            return void onFailure(invalidSignalingState(this.signalingState));
        }
        var parsed = sdpUtils.parseDescription(description);
        parsed.mediaSections.forEach(function(mediaSection) {
          mediaSection.candidates.forEach(this._iceTransport.addRemoteCandidate, this._iceTransport);
        }, this);
        this._startIceTransport(parsed.iceParameters[0]);
        this._startDtlsTransport(parsed.dtlsParameters[0]);
        if (this.signalingState === "have-local-offer") {
          parsed.mediaSections.forEach(this._receiveRtp, this);
          parsed.mediaSections.forEach(this._sendRtp, this);
        }
        this._remoteDescription = description;
        this._signalingState = nextSignalingState;
        onSuccess();
      };
      function invalidSignalingState(signalingState) {
        return new Error("Invalid signaling state: " + signalingState);
      }
      function isEmptyObject(object) {
        return !Object.keys(object).length;
      }
      function makeGatherOptions(configuration) {
        return {
          gatherPolicy: configuration.gatherPolicy || "all",
          iceServers: []
        };
      }
      function makeOnAddStreamEvent(stream) {
        return new MediaStreamEvent("addstream", {
          stream
        });
      }
      function makeOnIceCandidateEvent(candidate) {
        return new RTCPeerConnectionIceEvent("icecandidate", {
          candidate
        });
      }
      function makeORTCCandidate(candidate) {
        if (!candidate) {
          return {};
        }
        var start = candidate.candidate.indexOf("candidate:");
        var line = candidate.candidate.slice(start + 10).replace(/ +/g, " ").split(" ");
        var ortcIceCandidate = {
          foundation: line[0],
          protocol: line[2],
          priority: parseInt(line[3]),
          ip: line[4],
          port: parseInt(line[5]),
          type: line[7],
          relatedAddress: null,
          relatedPort: 0,
          tcpType: "active"
        };
        if (ortcIceCandidate.type !== "host") {
          ortcIceCandidate.relatedAddress = line[9];
          ortcIceCandidate.relatedPort = parseInt(line[11]);
        }
        return ortcIceCandidate;
      }
      function makeWebRTCCandidate(candidate) {
        if (isEmptyObject(candidate)) {
          return null;
        }
        var line = [
          "a=candidate",
          candidate.foundation,
          1,
          candidate.protocol,
          candidate.priority,
          candidate.ip,
          candidate.port,
          candidate.type
        ];
        if (candidate.relatedAddress) {
          line = line.concat([
            "raddr",
            candidate.relatedAddress,
            "rport",
            candidate.relatedPort
          ]);
        }
        line.push("generation 0");
        return new RTCIceCandidate2({
          candidate: line.join(" "),
          sdpMLineIndex: 0
        });
      }
      function intersectCodecs(localCodecs, remoteCodecs) {
        var sharedCodecs = [];
        localCodecs.forEach(function(localCodec) {
          remoteCodecs.forEach(function(remoteCodec) {
            if (localCodec.name === remoteCodec.name && localCodec.clockRate === remoteCodec.clockRate && localCodec.numChannels === remoteCodec.numChannels) {
              sharedCodecs.push(remoteCodec);
            }
          });
        });
        return sharedCodecs;
      }
      module2.exports = RTCPeerConnection;
    }, { "./mediasection": 23, "./mediastreamevent": 24, "./rtcicecandidate": 25, "./rtcpeerconnectioniceevent": 27, "./rtcsessiondescription": 28, "./sdp-utils": 29, "sdp-transform": 31 }], 27: [function(require2, module2, exports2) {
      "use strict";
      function RTCPeerConnectionIceEvent(type, init) {
        if (!(this instanceof RTCPeerConnectionIceEvent)) {
          return new RTCPeerConnectionIceEvent(type, init);
        }
        Event.call(this, type, init);
        Object.defineProperties(this, {
          candidate: {
            enumerable: true,
            value: init.candidate
          }
        });
      }
      module2.exports = RTCPeerConnectionIceEvent;
    }, {}], 28: [function(require2, module2, exports2) {
      "use strict";
      function RTCSessionDescription2(description) {
        if (!(this instanceof RTCSessionDescription2)) {
          return new RTCSessionDescription2(description);
        }
        Object.defineProperties(this, {
          sdp: {
            enumerable: true,
            value: description.sdp
          },
          type: {
            enumerable: true,
            value: description.type
          }
        });
      }
      module2.exports = RTCSessionDescription2;
    }, {}], 29: [function(require2, module2, exports2) {
      "use strict";
      var MediaSection = require2("./mediasection");
      var sdpTransform = require2("sdp-transform");
      function addCandidatesToLevel(level, candidates, component) {
        level = level || {};
        level.candidates = level.candidates || [];
        if (!candidates) {
          return level;
        }
        candidates.forEach(function(candidate) {
          if (!candidate.foundation) {
            level.endOfCandidates = "end-of-candidates";
            return;
          }
          var candidate1 = {
            foundation: candidate.foundation,
            transport: candidate.protocol,
            priority: candidate.priority,
            ip: candidate.ip,
            port: candidate.port,
            type: candidate.type,
            generation: 0
          };
          if (candidate.relatedAddress) {
            candidate1.raddr = candidate.relatedAddress;
            candidate1.rport = candidate.relatedPort;
          }
          if (typeof component === "number") {
            candidate1.component = component;
            level.candidates.push(candidate1);
            return;
          }
          candidate1.component = 1;
          level.candidates.push(candidate1);
          var candidate2 = {};
          for (var key in candidate1) {
            candidate2[key] = candidate1[key];
          }
          candidate2.component = 2;
          level.candidates.push(candidate2);
        });
        return level;
      }
      function addCandidatesToMediaLevels(sdp, candidates, component) {
        sdp = sdp || {};
        if (!sdp.media) {
          return sdp;
        }
        sdp.media.forEach(function(media) {
          addCandidatesToLevel(media, candidates, component);
        });
        return sdp;
      }
      function addCandidatesToSDPBlob(sdp, candidates, component) {
        sdp = sdp || {};
        addCandidatesToMediaLevels(sdp, candidates, component);
        return sdp;
      }
      function addDtlsParametersToSDPBlob(sdp, dtlsParameters) {
        sdp = sdp || {};
        addDtlsParametersToMediaLevels(sdp, dtlsParameters);
        return sdp;
      }
      function addDtlsParametersToLevel(level, dtlsParameters) {
        level = level || {};
        var fingerprints = dtlsParameters.fingerprints;
        if (fingerprints.length) {
          level.fingerprint = {
            type: fingerprints[0].algorithm,
            hash: fingerprints[0].value
          };
        }
        return level;
      }
      function addDtlsParametersToMediaLevels(sdp, dtlsParameters) {
        sdp = sdp || {};
        if (!sdp.media) {
          return sdp;
        }
        sdp.media.forEach(function(media) {
          addDtlsParametersToLevel(media, dtlsParameters);
        });
        return sdp;
      }
      function addIceParametersToSDPBlob(sdp, iceParameters) {
        sdp = sdp || {};
        addIceParametersToMediaLevels(sdp, iceParameters);
        return sdp;
      }
      function addIceParametersToMediaLevels(sdp, iceParameters) {
        sdp = sdp || {};
        if (!sdp.media) {
          return sdp;
        }
        sdp.media.forEach(function(media) {
          addIceParametersToLevel(media, iceParameters);
        });
        return sdp;
      }
      function addIceParametersToLevel(level, iceParameters) {
        level = level || {};
        level.iceUfrag = iceParameters.usernameFragment;
        level.icePwd = iceParameters.password;
        return level;
      }
      function addMediaSectionToSDPBlob(sdp, mediaSection) {
        var streamId = mediaSection.streamId;
        if (streamId) {
          sdp.msidSemantic = sdp.msidSemantic || {
            semantic: "WMS",
            token: []
          };
          sdp.msidSemantic.token.push(streamId);
        }
        var mid = mediaSection.mid;
        if (mid) {
          sdp.groups = sdp.groups || [];
          var foundBundle = false;
          sdp.groups.forEach(function(group) {
            if (group.type === "BUNDLE") {
              group.mids.push(mid);
              foundBundle = true;
            }
          });
          if (!foundBundle) {
            sdp.groups.push({
              type: "BUNDLE",
              mids: [mid]
            });
          }
        }
        var payloads = [];
        var rtps = [];
        var fmtps = [];
        mediaSection.capabilities.codecs.forEach(function(codec) {
          var payload = codec.preferredPayloadType;
          payloads.push(payload);
          var rtp = {
            payload,
            codec: codec.name,
            rate: codec.clockRate
          };
          if (codec.numChannels > 1) {
            rtp.encoding = codec.numChannels;
          }
          rtps.push(rtp);
          switch (codec.name) {
            case "telephone-event":
              if (codec.parameters && codec.parameters.events) {
                fmtps.push({
                  payload,
                  config: codec.parameters.events
                });
              }
              break;
          }
        });
        var ssrcs = [];
        if (streamId && mediaSection.track) {
          var ssrc = Math.floor(Math.random() * 4294967296);
          var cname = makeCname();
          var trackId = mediaSection.track.id;
          ssrcs = ssrcs.concat([
            {
              id: ssrc,
              attribute: "cname",
              value: cname
            },
            {
              id: ssrc,
              attribute: "msid",
              value: mediaSection.streamId + " " + trackId
            },
            {
              id: ssrc,
              attribute: "mslabel",
              value: trackId
            },
            {
              id: ssrc,
              attribute: "label",
              value: trackId
            }
          ]);
        }
        var defaultCandidate = mediaSection.defaultCandidate;
        var media = {
          rtp: rtps,
          fmtp: fmtps,
          type: mediaSection.kind,
          port: defaultCandidate ? defaultCandidate.port : 9,
          payloads: payloads.join(" "),
          protocol: "RTP/SAVPF",
          direction: mediaSection.direction,
          connection: {
            version: 4,
            ip: defaultCandidate ? defaultCandidate.ip : "0.0.0.0"
          },
          rtcp: {
            port: defaultCandidate ? defaultCandidate.port : 9,
            netType: "IN",
            ipVer: 4,
            address: defaultCandidate ? defaultCandidate.ip : "0.0.0.0"
          },
          ssrcs
        };
        if (mid) {
          media.mid = mid;
        }
        if (mediaSection.rtcpMux) {
          media.rtcpMux = "rtcp-mux";
        }
        addCandidatesToLevel(media, mediaSection.candidates);
        sdp.media.push(media);
        return sdp;
      }
      function addMediaSectionsToSDPBlob(sdp, mediaSections) {
        mediaSections.forEach(addMediaSectionToSDPBlob.bind(null, sdp));
        return sdp;
      }
      function makeInitialSDPBlob(sessionId) {
        sessionId = sessionId || Math.floor(Math.random() * 4294967296);
        return {
          version: 0,
          origin: {
            username: "-",
            sessionId,
            sessionVersion: 0,
            netType: "IN",
            ipVer: 4,
            address: "127.0.0.1"
          },
          name: "-",
          timing: {
            start: 0,
            stop: 0
          },
          connection: {
            version: 4,
            ip: "0.0.0.0"
          },
          media: []
        };
      }
      function parseDescription(description) {
        var sdp = sdpTransform.parse(description.sdp);
        var iceParameters = [];
        var dtlsParameters = [];
        var candidates = [];
        var mediaSections = [];
        var levels = [sdp];
        if (sdp.media) {
          levels = levels.concat(sdp.media);
        }
        levels.forEach(function(level) {
          if (level.iceUfrag && level.icePwd && level.fingerprint) {
            iceParameters.push({
              usernameFragment: level.iceUfrag,
              password: level.icePwd
            });
            dtlsParameters.push({
              fingerprints: [
                {
                  algorithm: level.fingerprint.type,
                  value: level.fingerprint.hash
                }
              ]
            });
          }
          if (level.rtp) {
            if (level.type === "video") {
              return;
            }
            var address = level.connection ? level.connection.ip : null;
            var direction = level.direction;
            var kind = level.type;
            var mid = level.mid;
            var port = level.port || null;
            var rtcpMux = level.rtcpMux === "rtcp-mux";
            var cname;
            var ssrc;
            var streamId;
            (level.ssrcs || []).forEach(function(attribute) {
              switch (attribute.attribute) {
                case "cname":
                  ssrc = attribute.id;
                  cname = attribute.value;
                  break;
                case "label":
                case "mslabel":
                  ssrc = attribute.id;
                  break;
                case "msid":
                  ssrc = attribute.id;
                  streamId = attribute.value.split(" ")[0];
                  break;
              }
            });
            var capabilities = {
              type: kind,
              muxId: mid,
              codecs: level.rtp.map(function(rtp) {
                var codec = {
                  name: rtp.codec,
                  payloadType: parseInt(rtp.payload),
                  clockRate: parseInt(rtp.rate),
                  numChannels: rtp.encoding || 1,
                  rtcpFeedback: [],
                  parameters: {}
                };
                switch (rtp.codec) {
                  case "telephone-event":
                    codec.parameters.events = "0-16";
                    break;
                }
                return codec;
              }),
              headerExtensions: [],
              encodings: level.rtp.map(function(rtp) {
                return {
                  ssrc,
                  codecPayloadType: parseInt(rtp.payload),
                  active: true
                };
              }),
              rtcp: {
                ssrc,
                cname,
                mux: rtcpMux
              }
            };
            var mediaSection = new MediaSection(address, candidates, capabilities, direction, kind, mid, port, rtcpMux, streamId);
            (level.candidates || []).forEach(function(candidate) {
              var ortcCandidate = {
                foundation: String(candidate.foundation),
                protocol: candidate.transport,
                priority: candidate.priority,
                ip: candidate.ip,
                port: candidate.port,
                type: candidate.type,
                relatedAddress: candidate.raddr,
                relatedPort: candidate.rport
              };
              candidates.push(ortcCandidate);
              mediaSection.addCandidate(ortcCandidate);
            });
            if (level.endOfCandidates === "end-of-candidates") {
              mediaSection.addCandidate({});
            }
            mediaSections.push(mediaSection);
          }
        });
        return {
          iceParameters,
          dtlsParameters,
          mediaSections
        };
      }
      function makeCname() {
        var a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/".split("");
        var n = 16;
        var cname = "";
        while (n--) {
          cname += a[Math.floor(Math.random() * a.length)];
        }
        return cname;
      }
      module2.exports.addCandidatesToSDPBlob = addCandidatesToSDPBlob;
      module2.exports.addDtlsParametersToSDPBlob = addDtlsParametersToSDPBlob;
      module2.exports.addIceParametersToSDPBlob = addIceParametersToSDPBlob;
      module2.exports.addMediaSectionsToSDPBlob = addMediaSectionsToSDPBlob;
      module2.exports.makeInitialSDPBlob = makeInitialSDPBlob;
      module2.exports.parseDescription = parseDescription;
    }, { "./mediasection": 23, "sdp-transform": 31 }], 30: [function(require2, module2, exports2) {
      var grammar = module2.exports = {
        v: [{
          name: "version",
          reg: /^(\d*)$/
        }],
        o: [{
          name: "origin",
          reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
          names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
          format: "%s %s %d %s IP%d %s"
        }],
        s: [{ name: "name" }],
        i: [{ name: "description" }],
        u: [{ name: "uri" }],
        e: [{ name: "email" }],
        p: [{ name: "phone" }],
        z: [{ name: "timezones" }],
        r: [{ name: "repeats" }],
        t: [{
          name: "timing",
          reg: /^(\d*) (\d*)/,
          names: ["start", "stop"],
          format: "%d %d"
        }],
        c: [{
          name: "connection",
          reg: /^IN IP(\d) (\S*)/,
          names: ["version", "ip"],
          format: "IN IP%d %s"
        }],
        b: [{
          push: "bandwidth",
          reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
          names: ["type", "limit"],
          format: "%s:%s"
        }],
        m: [{
          reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
          names: ["type", "port", "protocol", "payloads"],
          format: "%s %d %s %s"
        }],
        a: [
          {
            push: "rtp",
            reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
            names: ["payload", "codec", "rate", "encoding"],
            format: function(o) {
              return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
            }
          },
          {
            push: "fmtp",
            reg: /^fmtp:(\d*) ([\S| ]*)/,
            names: ["payload", "config"],
            format: "fmtp:%d %s"
          },
          {
            name: "control",
            reg: /^control:(.*)/,
            format: "control:%s"
          },
          {
            name: "rtcp",
            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
            names: ["port", "netType", "ipVer", "address"],
            format: function(o) {
              return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
            }
          },
          {
            push: "rtcpFbTrrInt",
            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
            names: ["payload", "value"],
            format: "rtcp-fb:%d trr-int %d"
          },
          {
            push: "rtcpFb",
            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
            names: ["payload", "type", "subtype"],
            format: function(o) {
              return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
            }
          },
          {
            push: "ext",
            reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
            names: ["value", "uri", "config"],
            format: function(o) {
              return o.config != null ? "extmap:%s %s %s" : "extmap:%s %s";
            }
          },
          {
            push: "crypto",
            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
            names: ["id", "suite", "config", "sessionConfig"],
            format: function(o) {
              return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
            }
          },
          {
            name: "setup",
            reg: /^setup:(\w*)/,
            format: "setup:%s"
          },
          {
            name: "mid",
            reg: /^mid:([^\s]*)/,
            format: "mid:%s"
          },
          {
            name: "msid",
            reg: /^msid:(.*)/,
            format: "msid:%s"
          },
          {
            name: "ptime",
            reg: /^ptime:(\d*)/,
            format: "ptime:%d"
          },
          {
            name: "maxptime",
            reg: /^maxptime:(\d*)/,
            format: "maxptime:%d"
          },
          {
            name: "direction",
            reg: /^(sendrecv|recvonly|sendonly|inactive)/
          },
          {
            name: "icelite",
            reg: /^(ice-lite)/
          },
          {
            name: "iceUfrag",
            reg: /^ice-ufrag:(\S*)/,
            format: "ice-ufrag:%s"
          },
          {
            name: "icePwd",
            reg: /^ice-pwd:(\S*)/,
            format: "ice-pwd:%s"
          },
          {
            name: "fingerprint",
            reg: /^fingerprint:(\S*) (\S*)/,
            names: ["type", "hash"],
            format: "fingerprint:%s %s"
          },
          {
            push: "candidates",
            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?/,
            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation"],
            format: function(o) {
              var str = "candidate:%s %d %s %d %s %d typ %s";
              str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
              str += o.tcptype != null ? " tcptype %s" : "%v";
              if (o.generation != null) {
                str += " generation %d";
              }
              return str;
            }
          },
          {
            name: "endOfCandidates",
            reg: /^(end-of-candidates)/
          },
          {
            name: "remoteCandidates",
            reg: /^remote-candidates:(.*)/,
            format: "remote-candidates:%s"
          },
          {
            name: "iceOptions",
            reg: /^ice-options:(\S*)/,
            format: "ice-options:%s"
          },
          {
            push: "ssrcs",
            reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
            names: ["id", "attribute", "value"],
            format: "ssrc:%d %s:%s"
          },
          {
            push: "ssrcGroups",
            reg: /^ssrc-group:(\w*) (.*)/,
            names: ["semantics", "ssrcs"],
            format: "ssrc-group:%s %s"
          },
          {
            name: "msidSemantic",
            reg: /^msid-semantic:\s?(\w*) (\S*)/,
            names: ["semantic", "token"],
            format: "msid-semantic: %s %s"
          },
          {
            push: "groups",
            reg: /^group:(\w*) (.*)/,
            names: ["type", "mids"],
            format: "group:%s %s"
          },
          {
            name: "rtcpMux",
            reg: /^(rtcp-mux)/
          },
          {
            name: "rtcpRsize",
            reg: /^(rtcp-rsize)/
          },
          {
            name: "sctpmap",
            reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
            names: ["sctpmapNumber", "app", "maxMessageSize"],
            format: function(o) {
              return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
            }
          },
          {
            push: "invalid",
            names: ["value"]
          }
        ]
      };
      Object.keys(grammar).forEach(function(key) {
        var objs = grammar[key];
        objs.forEach(function(obj) {
          if (!obj.reg) {
            obj.reg = /(.*)/;
          }
          if (!obj.format) {
            obj.format = "%s";
          }
        });
      });
    }, {}], 31: [function(require2, module2, exports2) {
      var parser = require2("./parser");
      var writer = require2("./writer");
      exports2.write = writer;
      exports2.parse = parser.parse;
      exports2.parseFmtpConfig = parser.parseFmtpConfig;
      exports2.parsePayloads = parser.parsePayloads;
      exports2.parseRemoteCandidates = parser.parseRemoteCandidates;
    }, { "./parser": 32, "./writer": 33 }], 32: [function(require2, module2, exports2) {
      var toIntIfInt = function(v) {
        return String(Number(v)) === v ? Number(v) : v;
      };
      var attachProperties = function(match, location2, names, rawName) {
        if (rawName && !names) {
          location2[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i2 = 0; i2 < names.length; i2 += 1) {
            if (match[i2 + 1] != null) {
              location2[names[i2]] = toIntIfInt(match[i2 + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location2, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location2[obj.push]) {
          location2[obj.push] = [];
        } else if (needsBlank && !location2[obj.name]) {
          location2[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : needsBlank ? location2[obj.name] : location2;
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location2[obj.push].push(keyLocation);
        }
      };
      var grammar = require2("./grammar");
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports2.parse = function(sdp) {
        var session = {}, media = [], location2 = session;
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
          var type = l[0];
          var content = l.slice(2);
          if (type === "m") {
            media.push({ rtp: [], fmtp: [] });
            location2 = media[media.length - 1];
          }
          for (var j = 0; j < (grammar[type] || []).length; j += 1) {
            var obj = grammar[type][j];
            if (obj.reg.test(content)) {
              return parseReg(obj, location2, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var fmtpReducer = function(acc, expr) {
        var s = expr.split(/=(.+)/, 2);
        if (s.length === 2) {
          acc[s[0]] = toIntIfInt(s[1]);
        }
        return acc;
      };
      exports2.parseFmtpConfig = function(str) {
        return str.split(/\;\s?/).reduce(fmtpReducer, {});
      };
      exports2.parsePayloads = function(str) {
        return str.split(" ").map(Number);
      };
      exports2.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i2 = 0; i2 < parts.length; i2 += 3) {
          candidates.push({
            component: parts[i2],
            ip: parts[i2 + 1],
            port: parts[i2 + 2]
          });
        }
        return candidates;
      };
    }, { "./grammar": 30 }], 33: [function(require2, module2, exports2) {
      var grammar = require2("./grammar");
      var formatRegExp = /%[sdv%]/g;
      var format = function(formatStr) {
        var i2 = 1;
        var args = arguments;
        var len = args.length;
        return formatStr.replace(formatRegExp, function(x) {
          if (i2 >= len) {
            return x;
          }
          var arg = args[i2];
          i2 += 1;
          switch (x) {
            case "%%":
              return "%";
            case "%s":
              return String(arg);
            case "%d":
              return Number(arg);
            case "%v":
              return "";
          }
        });
      };
      var makeLine = function(type, obj, location2) {
        var str = obj.format instanceof Function ? obj.format(obj.push ? location2 : location2[obj.name]) : obj.format;
        var args = [type + "=" + str];
        if (obj.names) {
          for (var i2 = 0; i2 < obj.names.length; i2 += 1) {
            var n = obj.names[i2];
            if (obj.name) {
              args.push(location2[obj.name][n]);
            } else {
              args.push(location2[obj.names[i2]]);
            }
          }
        } else {
          args.push(location2[obj.name]);
        }
        return format.apply(null, args);
      };
      var defaultOuterOrder = [
        "v",
        "o",
        "s",
        "i",
        "u",
        "e",
        "p",
        "c",
        "b",
        "t",
        "r",
        "z",
        "a"
      ];
      var defaultInnerOrder = ["i", "c", "b", "a"];
      module2.exports = function(session, opts) {
        opts = opts || {};
        if (session.version == null) {
          session.version = 0;
        }
        if (session.name == null) {
          session.name = " ";
        }
        session.media.forEach(function(mLine) {
          if (mLine.payloads == null) {
            mLine.payloads = "";
          }
        });
        var outerOrder = opts.outerOrder || defaultOuterOrder;
        var innerOrder = opts.innerOrder || defaultInnerOrder;
        var sdp = [];
        outerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in session && session[obj.name] != null) {
              sdp.push(makeLine(type, obj, session));
            } else if (obj.push in session && session[obj.push] != null) {
              session[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
        session.media.forEach(function(mLine) {
          sdp.push(makeLine("m", grammar.m[0], mLine));
          innerOrder.forEach(function(type) {
            grammar[type].forEach(function(obj) {
              if (obj.name in mLine && mLine[obj.name] != null) {
                sdp.push(makeLine(type, obj, mLine));
              } else if (obj.push in mLine && mLine[obj.push] != null) {
                mLine[obj.push].forEach(function(el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });
        });
        return sdp.join("\r\n") + "\r\n";
      };
    }, { "./grammar": 30 }], 34: [function(require2, module2, exports2) {
      (function(global2, factory) {
        if (typeof exports2 === "object") {
          module2.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          global2.printStackTrace = factory();
        }
      })(this, function() {
        function printStackTrace(options) {
          options = options || { guess: true };
          var ex = options.e || null, guess = !!options.guess, mode = options.mode || null;
          var p = new printStackTrace.implementation(), result = p.run(ex, mode);
          return guess ? p.guessAnonymousFunctions(result) : result;
        }
        printStackTrace.implementation = function() {
        };
        printStackTrace.implementation.prototype = {
          run: function(ex, mode) {
            ex = ex || this.createException();
            mode = mode || this.mode(ex);
            if (mode === "other") {
              return this.other(arguments.callee);
            } else {
              return this[mode](ex);
            }
          },
          createException: function() {
            try {
              this.undef();
            } catch (e) {
              return e;
            }
          },
          mode: function(e) {
            if (typeof window !== "undefined" && window.navigator.userAgent.indexOf("PhantomJS") > -1) {
              return "phantomjs";
            }
            if (e["arguments"] && e.stack) {
              return "chrome";
            }
            if (e.stack && e.sourceURL) {
              return "safari";
            }
            if (e.stack && e.number) {
              return "ie";
            }
            if (e.stack && e.fileName) {
              return "firefox";
            }
            if (e.message && e["opera#sourceloc"]) {
              if (!e.stacktrace) {
                return "opera9";
              }
              if (e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length) {
                return "opera9";
              }
              return "opera10a";
            }
            if (e.message && e.stack && e.stacktrace) {
              if (e.stacktrace.indexOf("called from line") < 0) {
                return "opera10b";
              }
              return "opera11";
            }
            if (e.stack && !e.fileName) {
              return "chrome";
            }
            return "other";
          },
          instrumentFunction: function(context, functionName, callback) {
            context = context || window;
            var original = context[functionName];
            context[functionName] = function instrumented() {
              callback.call(this, printStackTrace().slice(4));
              return context[functionName]._instrumented.apply(this, arguments);
            };
            context[functionName]._instrumented = original;
          },
          deinstrumentFunction: function(context, functionName) {
            if (context[functionName].constructor === Function && context[functionName]._instrumented && context[functionName]._instrumented.constructor === Function) {
              context[functionName] = context[functionName]._instrumented;
            }
          },
          chrome: function(e) {
            return (e.stack + "\n").replace(/^[\s\S]+?\s+at\s+/, " at ").replace(/^\s+(at eval )?at\s+/gm, "").replace(/^([^\(]+?)([\n$])/gm, "{anonymous}() ($1)$2").replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, "{anonymous}() ($1)").replace(/^(.+) \((.+)\)$/gm, "$1@$2").split("\n").slice(0, -1);
          },
          safari: function(e) {
            return e.stack.replace(/\[native code\]\n/m, "").replace(/^(?=\w+Error\:).*$\n/m, "").replace(/^@/gm, "{anonymous}()@").split("\n");
          },
          ie: function(e) {
            return e.stack.replace(/^\s*at\s+(.*)$/gm, "$1").replace(/^Anonymous function\s+/gm, "{anonymous}() ").replace(/^(.+)\s+\((.+)\)$/gm, "$1@$2").split("\n").slice(1);
          },
          firefox: function(e) {
            return e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^(?:\((\S*)\))?@/gm, "{anonymous}($1)@").split("\n");
          },
          opera11: function(e) {
            var ANON = "{anonymous}", lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
            var lines = e.stacktrace.split("\n"), result = [];
            for (var i2 = 0, len = lines.length; i2 < len; i2 += 2) {
              var match = lineRE.exec(lines[i2]);
              if (match) {
                var location2 = match[4] + ":" + match[1] + ":" + match[2];
                var fnName = match[3] || "global code";
                fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                result.push(fnName + "@" + location2 + " -- " + lines[i2 + 1].replace(/^\s+/, ""));
              }
            }
            return result;
          },
          opera10b: function(e) {
            var lineRE = /^(.*)@(.+):(\d+)$/;
            var lines = e.stacktrace.split("\n"), result = [];
            for (var i2 = 0, len = lines.length; i2 < len; i2++) {
              var match = lineRE.exec(lines[i2]);
              if (match) {
                var fnName = match[1] ? match[1] + "()" : "global code";
                result.push(fnName + "@" + match[2] + ":" + match[3]);
              }
            }
            return result;
          },
          opera10a: function(e) {
            var ANON = "{anonymous}", lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split("\n"), result = [];
            for (var i2 = 0, len = lines.length; i2 < len; i2 += 2) {
              var match = lineRE.exec(lines[i2]);
              if (match) {
                var fnName = match[3] || ANON;
                result.push(fnName + "()@" + match[2] + ":" + match[1] + " -- " + lines[i2 + 1].replace(/^\s+/, ""));
              }
            }
            return result;
          },
          opera9: function(e) {
            var ANON = "{anonymous}", lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split("\n"), result = [];
            for (var i2 = 2, len = lines.length; i2 < len; i2 += 2) {
              var match = lineRE.exec(lines[i2]);
              if (match) {
                result.push(ANON + "()@" + match[2] + ":" + match[1] + " -- " + lines[i2 + 1].replace(/^\s+/, ""));
              }
            }
            return result;
          },
          phantomjs: function(e) {
            var ANON = "{anonymous}", lineRE = /(\S+) \((\S+)\)/i;
            var lines = e.stack.split("\n"), result = [];
            for (var i2 = 1, len = lines.length; i2 < len; i2++) {
              lines[i2] = lines[i2].replace(/^\s+at\s+/gm, "");
              var match = lineRE.exec(lines[i2]);
              if (match) {
                result.push(match[1] + "()@" + match[2]);
              } else {
                result.push(ANON + "()@" + lines[i2]);
              }
            }
            return result;
          },
          other: function(curr) {
            var ANON = "{anonymous}", fnRE = /function(?:\s+([\w$]+))?\s*\(/, stack = [], fn, args, maxStackSize = 10;
            var slice = Array.prototype.slice;
            while (curr && stack.length < maxStackSize) {
              fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
              try {
                args = slice.call(curr["arguments"] || []);
              } catch (e) {
                args = ["Cannot access arguments: " + e];
              }
              stack[stack.length] = fn + "(" + this.stringifyArguments(args) + ")";
              try {
                curr = curr.caller;
              } catch (e) {
                stack[stack.length] = "Cannot access caller: " + e;
                break;
              }
            }
            return stack;
          },
          stringifyArguments: function(args) {
            var result = [];
            var slice = Array.prototype.slice;
            for (var i2 = 0; i2 < args.length; ++i2) {
              var arg = args[i2];
              if (arg === void 0) {
                result[i2] = "undefined";
              } else if (arg === null) {
                result[i2] = "null";
              } else if (arg.constructor) {
                if (arg.constructor === Array) {
                  if (arg.length < 3) {
                    result[i2] = "[" + this.stringifyArguments(arg) + "]";
                  } else {
                    result[i2] = "[" + this.stringifyArguments(slice.call(arg, 0, 1)) + "..." + this.stringifyArguments(slice.call(arg, -1)) + "]";
                  }
                } else if (arg.constructor === Object) {
                  result[i2] = "#object";
                } else if (arg.constructor === Function) {
                  result[i2] = "#function";
                } else if (arg.constructor === String) {
                  result[i2] = '"' + arg + '"';
                } else if (arg.constructor === Number) {
                  result[i2] = arg;
                } else {
                  result[i2] = "?";
                }
              }
            }
            return result.join(",");
          },
          sourceCache: {},
          ajax: function(url) {
            var req = this.createXMLHTTPObject();
            if (req) {
              try {
                req.open("GET", url, false);
                req.send(null);
                return req.responseText;
              } catch (e) {
              }
            }
            return "";
          },
          createXMLHTTPObject: function() {
            var xmlhttp, XMLHttpFactories = [
              function() {
                return new XMLHttpRequest();
              },
              function() {
                return new ActiveXObject("Msxml2.XMLHTTP");
              },
              function() {
                return new ActiveXObject("Msxml3.XMLHTTP");
              },
              function() {
                return new ActiveXObject("Microsoft.XMLHTTP");
              }
            ];
            for (var i2 = 0; i2 < XMLHttpFactories.length; i2++) {
              try {
                xmlhttp = XMLHttpFactories[i2]();
                this.createXMLHTTPObject = XMLHttpFactories[i2];
                return xmlhttp;
              } catch (e) {
              }
            }
          },
          isSameDomain: function(url) {
            return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1;
          },
          getSource: function(url) {
            if (!(url in this.sourceCache)) {
              this.sourceCache[url] = this.ajax(url).split("\n");
            }
            return this.sourceCache[url];
          },
          guessAnonymousFunctions: function(stack) {
            for (var i2 = 0; i2 < stack.length; ++i2) {
              var reStack = /\{anonymous\}\(.*\)@(.*)/, reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/, frame = stack[i2], ref = reStack.exec(frame);
              if (ref) {
                var m = reRef.exec(ref[1]);
                if (m) {
                  var file = m[1], lineno = m[2], charno = m[3] || 0;
                  if (file && this.isSameDomain(file) && lineno) {
                    var functionName = this.guessAnonymousFunction(file, lineno, charno);
                    stack[i2] = frame.replace("{anonymous}", functionName);
                  }
                }
              }
            }
            return stack;
          },
          guessAnonymousFunction: function(url, lineNo, charNo) {
            var ret;
            try {
              ret = this.findFunctionName(this.getSource(url), lineNo);
            } catch (e) {
              ret = "getSource failed with url: " + url + ", exception: " + e.toString();
            }
            return ret;
          },
          findFunctionName: function(source, lineNo) {
            var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
            var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
            var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
            var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
            for (var i2 = 0; i2 < maxLines; ++i2) {
              line = source[lineNo - i2 - 1];
              commentPos = line.indexOf("//");
              if (commentPos >= 0) {
                line = line.substr(0, commentPos);
              }
              if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                  return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                  return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                  return m[1];
                }
              }
            }
            return "(?)";
          }
        };
        return printStackTrace;
      });
    }, {}], 35: [function(require2, module2, exports2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }, {}], 36: [function(require2, module2, exports2) {
      module2.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }, {}], 37: [function(require2, module2, exports2) {
      var formatRegExp = /%[sdj%]/g;
      exports2.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            objects.push(inspect(arguments[i2]));
          }
          return objects.join(" ");
        }
        var i2 = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i2 >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i2]; i2 < len; x = args[++i2]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports2.deprecate = function(fn, msg) {
        if (isUndefined(global.process)) {
          return function() {
            return exports2.deprecate(fn, msg).apply(this, arguments);
          };
        }
        if (process.noDeprecation === true) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnviron;
      exports2.debuglog = function(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = process.env.NODE_DEBUG || "";
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports2.format.apply(exports2, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports2._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports2.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i2 = 0, l = value.length; i2 < l; ++i2) {
          if (hasOwnProperty(value, String(i2))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports2.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports2.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports2.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports2.isError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive;
      exports2.isBuffer = require2("./support/isBuffer");
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports2.log = function() {
        console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
      };
      exports2.inherits = require2("inherits");
      exports2._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i2 = keys.length;
        while (i2--) {
          origin[keys[i2]] = add[keys[i2]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }, { "./support/isBuffer": 36, "inherits": 35 }], 38: [function(require2, module2, exports2) {
      var global2 = function() {
        return this;
      }();
      var WebSocket = global2.WebSocket || global2.MozWebSocket;
      module2.exports = WebSocket ? ws : null;
      function ws(uri, protocols, opts) {
        var instance;
        if (protocols) {
          instance = new WebSocket(uri, protocols);
        } else {
          instance = new WebSocket(uri);
        }
        return instance;
      }
      if (WebSocket)
        ws.prototype = WebSocket.prototype;
    }, {}], 39: [function(require2, module2, exports2) {
      exports2.XMLHttpRequest = XMLHttpRequest;
    }, {}] }, {}, [1]);
  }
});

// dep:twilio-client-mirror
var twilio_client_mirror_default = require_twilio();
export {
  twilio_client_mirror_default as default
};
//# sourceMappingURL=twilio-client-mirror.js.map
